# -*- coding: utf-8 -*-

# --- 1. Gerekli KÃ¼tÃ¼phaneleri YÃ¼kle ---
# Flask: Web sunucusu framework'Ã¼
# Flask-Cors: TarayÄ±cÄ±larÄ±n farklÄ± kaynaklardan gelen isteklerine izin vermek iÃ§in (Cross-Origin Resource Sharing)
# requests: Harici API'lere HTTP istekleri gÃ¶ndermek iÃ§in
# pyngrok: Yerel Flask sunucusunu internete aÃ§mak iÃ§in (Colab'da kullanÄ±ÅŸlÄ±)
# google-generativeai: Google Gemini API'si iÃ§in resmi Python kÃ¼tÃ¼phanesi
!pip install Flask Flask-Cors requests pyngrok google-generativeai -q
print("Gerekli kÃ¼tÃ¼phaneler yÃ¼klendi.")

# --- 2. KÃ¼tÃ¼phaneleri ve ModÃ¼lleri Ä°Ã§e Aktar ---
import os
import requests
from flask import Flask, request, jsonify
from flask_cors import CORS
from pyngrok import ngrok, conf
import google.generativeai as genai
import threading # Flask'Ä± ayrÄ± bir thread'de Ã§alÄ±ÅŸtÄ±rmak iÃ§in (Colab'da bazen gerekli)
import json # JSON iÅŸleme iÃ§in
import glob # Dosya yolu eÅŸleÅŸtirme iÃ§in
from google.colab import drive # Google Drive baÄŸlamak iÃ§in
import re # Dosya adÄ± ve ID temizleme iÃ§in
import unicodedata # TÃ¼rkÃ§e karakterleri dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in

# --- 3. Google Drive'Ä± BaÄŸla ---
DRIVE_MOUNT_POINT = '/content/drive'
# KullanÄ±cÄ±nÄ±n belirttiÄŸi alt klasÃ¶r
DRIVE_CHAT_FOLDER = '/Aichatdrive' # KullanÄ±cÄ±nÄ±n belirttiÄŸi klasÃ¶r adÄ±
# Karakter JSON dosyalarÄ±nÄ±n bulunduÄŸu varsayÄ±lan yol
CHARACTER_JSON_PATH = os.path.join(DRIVE_MOUNT_POINT, 'MyDrive', DRIVE_CHAT_FOLDER.strip('/'), 'characters') # MyDrive/Aichatdrive/characters

try:
    drive.mount(DRIVE_MOUNT_POINT)
    print(f"Google Drive baÅŸarÄ±yla {DRIVE_MOUNT_POINT} adresine baÄŸlandÄ±.")
    # Karakter klasÃ¶rÃ¼nÃ¼ oluÅŸtur (varsa hata vermez)
    os.makedirs(CHARACTER_JSON_PATH, exist_ok=True)
    print(f"Karakter klasÃ¶rÃ¼ kontrol edildi/oluÅŸturuldu: {CHARACTER_JSON_PATH}")
    # Karakterleri yÃ¼kleme fonksiyonu burada Ã§aÄŸrÄ±lacak (aÅŸaÄŸÄ±da tanÄ±mlandÄ±)

except Exception as e:
    print(f"Google Drive baÄŸlanÄ±rken veya klasÃ¶r oluÅŸturulurken hata oluÅŸtu: {e}")
    print("Karakterler Drive'dan yÃ¼klenemeyecek veya kaydedilemeyecek.")
    # Hata durumunda boÅŸ liste ile devam et
    backend_characters = []


# --- 4. API AnahtarlarÄ±nÄ± ve Ngrok Token'Ä±nÄ± Al ---
# Google Colab'Ä±n Secrets (Gizli Anahtarlar) Ã¶zelliÄŸini kullanarak API anahtarlarÄ±nÄ± gÃ¼venli bir ÅŸekilde saklayÄ±n.
# Sol menÃ¼deki anahtar (ğŸ”‘) ikonuna tÄ±klayarak ÅŸu isimlerle ekleyin:
# GEMINI_API_KEY, OPENROUTER_API_KEY, NGROK_AUTHTOKEN
try:
    from google.colab import userdata
    GEMINI_API_KEY = userdata.get('GEMINI_API_KEY')
    OPENROUTER_API_KEY = userdata.get('OPENROUTER_API_KEY') # OpenRouter anahtarÄ±nÄ± al
    NGROK_AUTHTOKEN = userdata.get('NGROK_AUTHTOKEN')
    print("API anahtarlarÄ± ve Ngrok Authtoken Colab Secrets'tan baÅŸarÄ±yla alÄ±ndÄ±.")

    # Gemini API'sini yapÄ±landÄ±r
    if GEMINI_API_KEY:
        genai.configure(api_key=GEMINI_API_KEY)
        print("Google Gemini API baÅŸarÄ±yla yapÄ±landÄ±rÄ±ldÄ±.")
    else:
        print("UyarÄ±: Colab Secrets'ta 'GEMINI_API_KEY' bulunamadÄ±. Gemini modelleri Ã§alÄ±ÅŸmayacak.")

    # Ngrok'u yapÄ±landÄ±r (Ngrok tÃ¼nelinin kimlik doÄŸrulamasÄ± iÃ§in)
    if NGROK_AUTHTOKEN:
        conf.get_default().auth_token = NGROK_AUTHTOKEN
        print("Ngrok Authtoken baÅŸarÄ±yla ayarlandÄ±.")
    else:
        print("UyarÄ±: Colab Secrets'ta 'NGROK_AUTHTOKEN' bulunamadÄ±. Ngrok tÃ¼neli kÄ±sÄ±tlÄ± olabilir veya Ã§alÄ±ÅŸmayabilir.")

    # OpenRouter anahtarÄ±nÄ±n varlÄ±ÄŸÄ±nÄ± kontrol et
    if not OPENROUTER_API_KEY:
        print("UyarÄ±: Colab Secrets'ta 'OPENROUTER_API_KEY' bulunamadÄ±. OpenRouter modelleri Ã§alÄ±ÅŸmayacak.")

# Colab ortamÄ±nda deÄŸilse veya userdata modÃ¼lÃ¼ yoksa
except ImportError:
    print("Google Colab ortamÄ±nda deÄŸilsiniz veya 'userdata' modÃ¼lÃ¼ bulunamadÄ±. API anahtarlarÄ± manuel olarak ayarlanmalÄ± veya ortam deÄŸiÅŸkenlerinden okunmalÄ±.")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None
# Secrets'ta anahtar eksikse
except KeyError as e:
     print(f"Colab Secrets'ta eksik anahtar: {e}. LÃ¼tfen sol menÃ¼den (ğŸ”‘) gerekli anahtarlarÄ± ekleyin.")
     # Eksik anahtarlarÄ± None olarak ayarla ki program devam edebilsin (ama ilgili API Ã§alÄ±ÅŸmaz)
     if 'GEMINI_API_KEY' not in locals(): GEMINI_API_KEY = None
     if 'OPENROUTER_API_KEY' not in locals(): OPENROUTER_API_KEY = None
     if 'NGROK_AUTHTOKEN' not in locals(): NGROK_AUTHTOKEN = None
# DiÄŸer beklenmedik hatalar
except Exception as e:
    print(f"API anahtarÄ± veya Ngrok token yapÄ±landÄ±rÄ±lÄ±rken genel bir hata oluÅŸtu: {e}")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None


# --- 5. Karakterleri Drive'dan YÃ¼kleme Fonksiyonu ---
def load_characters_from_drive(path):
    """
    Belirtilen yoldaki tÃ¼m .json dosyalarÄ±nÄ± okuyarak karakter listesini oluÅŸturur.
    Her JSON dosyasÄ±nÄ±n bir karakteri temsil ettiÄŸi varsayÄ±lÄ±r.
    JSON formatÄ±: {"id": "...", "name": "...", "avatar": "...", "description": "...", "tags": [...], "isPremium": true/false}
    """
    characters = []
    # KlasÃ¶rÃ¼n varlÄ±ÄŸÄ±nÄ± tekrar kontrol et (Drive baÄŸlantÄ±sÄ± kopmuÅŸ olabilir)
    if not os.path.isdir(path):
        print(f"UyarÄ±: Karakter yÃ¼kleme sÄ±rasÄ±nda klasÃ¶r bulunamadÄ±: {path}")
        return []

    json_files = glob.glob(os.path.join(path, '*.json')) # KlasÃ¶rdeki tÃ¼m .json dosyalarÄ±nÄ± bul
    print(f"Bulunan JSON dosyalarÄ± ({len(json_files)} adet): {json_files}")

    if not json_files:
        print(f"UyarÄ±: '{path}' iÃ§inde hiÃ§ JSON dosyasÄ± bulunamadÄ±.")
        return []

    for file_path in json_files:
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                char_data = json.load(f)

                # Gerekli alanlarÄ±n varlÄ±ÄŸÄ±nÄ± ve tÃ¼rÃ¼nÃ¼ kontrol et (basit kontrol)
                if all(k in char_data for k in ['id', 'name', 'avatar', 'description', 'tags', 'isPremium']) and \
                   isinstance(char_data['tags'], list) and \
                   isinstance(char_data['isPremium'], bool):
                    characters.append(char_data)
                    print(f"BaÅŸarÄ±yla yÃ¼klendi: {char_data.get('name')} ({os.path.basename(file_path)})")
                else:
                    print(f"UyarÄ±: '{os.path.basename(file_path)}' dosyasÄ±nda eksik veya yanlÄ±ÅŸ formatta alanlar var. AtlanÄ±yor.")

        except json.JSONDecodeError:
            print(f"Hata: '{os.path.basename(file_path)}' dosyasÄ± geÃ§erli bir JSON deÄŸil. AtlanÄ±yor.")
        except Exception as e:
            print(f"Hata: '{os.path.basename(file_path)}' dosyasÄ± okunurken hata oluÅŸtu: {e}. AtlanÄ±yor.")

    print(f"Toplam {len(characters)} karakter Drive'dan yÃ¼klendi.")
    return characters

# Drive baÄŸlandÄ±ktan ve klasÃ¶r kontrol edildikten sonra karakterleri yÃ¼kle
if 'backend_characters' not in locals(): # EÄŸer Drive baÄŸlanÄ±rken hata olduysa bu deÄŸiÅŸken tanÄ±mlanmamÄ±ÅŸ olabilir
     backend_characters = []
if os.path.isdir(CHARACTER_JSON_PATH): # Sadece klasÃ¶r varsa yÃ¼klemeyi dene
    backend_characters = load_characters_from_drive(CHARACTER_JSON_PATH)
else:
    # KlasÃ¶r yoksa yÃ¼kleme zaten yapÄ±lamaz, boÅŸ liste ile devam edilir
    if 'backend_characters' not in locals(): # Hata durumunda tanÄ±mlanmamÄ±ÅŸ olabilir
        backend_characters = []
    print(f"UyarÄ±: Karakter klasÃ¶rÃ¼ '{CHARACTER_JSON_PATH}' bulunamadÄ±ÄŸÄ± iÃ§in karakter yÃ¼klenemedi.")


# --- 6. YardÄ±mcÄ± Fonksiyonlar (Formatlama ve Temizleme) ---

def format_card_for_aichatdrive(original_card_data, default_avatar=""):
    """
    SillyTavern kartÄ±nÄ± Aichatdrive formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.
    """
    if not isinstance(original_card_data, dict):
        print("Hata: Girdi bir sÃ¶zlÃ¼k olmalÄ±dÄ±r.")
        return None

    data = original_card_data.get('data', original_card_data) # Handle V2 structure

    new_format = {}

    # --- AlanlarÄ± Ã‡Ä±kar veya OluÅŸtur ---
    char_name = data.get('name', data.get('char_name', ''))
    if not char_name:
        print("Hata: Karakter adÄ± bulunamadÄ±.")
        return None # Ä°simsiz kart olmaz

    # ID OluÅŸturma
    normalized_name = unicodedata.normalize('NFKD', char_name).encode('ASCII', 'ignore').decode('ASCII')
    sanitized_id = re.sub(r'\s+', '-', normalized_name.lower())
    sanitized_id = re.sub(r'[^\w\-]', '', sanitized_id)
    new_format['id'] = sanitized_id if sanitized_id else "default-id"

    new_format['name'] = char_name

    # Avatar: Ã–nce data['avatar'] kontrol et, sonra parametreye bak
    avatar_url = data.get('avatar') # Try finding it within 'data'
    # If not found in 'data' AND 'data' structure was used, try checking root level as fallback
    if not avatar_url and original_card_data.get('data') is data:
        avatar_url = original_card_data.get('avatar')

    new_format['avatar'] = avatar_url if avatar_url else default_avatar # Use found URL or default

    # Description
    description_text = data.get('description', data.get('char_persona', ''))
    new_format['description'] = description_text

    # Tags
    new_format['tags'] = data.get('tags', [])
    if not isinstance(new_format['tags'], list):
        new_format['tags'] = []

    # isPremium
    new_format['isPremium'] = data.get('isPremium', False) # Check if it exists in input, default false

    return new_format

def sanitize_filename(name):
    """Ä°simden gÃ¼venli bir dosya adÄ± oluÅŸturur."""
    # TÃ¼rkÃ§e karakterleri dÃ¶nÃ¼ÅŸtÃ¼r
    name = unicodedata.normalize('NFKD', name).encode('ASCII', 'ignore').decode('ASCII')
    # GeÃ§ersiz karakterleri kaldÄ±r veya deÄŸiÅŸtir (boÅŸluk yerine _)
    name = re.sub(r'[^\w\.\-]', '_', name)
    # Ã‡oklu alt Ã§izgileri teke indir
    name = re.sub(r'_+', '_', name)
    # BaÅŸta veya sonda olabilecek alt Ã§izgileri kaldÄ±r
    name = name.strip('_')
    return name if name else "unnamed_character"


# --- 7. Flask UygulamasÄ±nÄ± BaÅŸlat ---
app = Flask(__name__)
# CORS(app) tÃ¼m kaynaklardan gelen isteklere izin verir.
CORS(app)

# --- 8. Bilinen Modeller (Bilgi amaÃ§lÄ±) ---
# Bu liste API yÃ¶nlendirmesi iÃ§in kullanÄ±labilir.
known_models_info = {
    # Gemini Modelleri (Google)
    "gemini-pro": { "name": "Gemini 1.0 Pro (Google)", "provider": "google" },
    "gemini-1.5-flash-latest": { "name": "Gemini 1.5 Flash (Google)", "provider": "google" },
    # OpenRouter Ã–rnekleri
    "openai/gpt-4o-mini": { "name": "GPT-4o Mini (OpenRouter)", "provider": "openrouter" },
    "anthropic/claude-3-haiku-20240307": { "name": "Claude 3 Haiku (OpenRouter)", "provider": "openrouter" },
    "mistralai/mistral-7b-instruct": { "name": "Mistral 7B Instruct (OpenRouter)", "provider": "openrouter" },
    "google/gemini-pro": { "name": "Gemini Pro (OpenRouter)", "provider": "openrouter" },
    "gryphe/mythomax-l2-13b": { "name": "MythoMax L2 13B (OpenRouter)", "provider": "openrouter", "isPremium": True }
}


# --- 9. AI API Ã‡aÄŸrÄ± FonksiyonlarÄ± ---

def call_gemini_api(prompt, model_id="gemini-pro", persona="", history=None):
    """
    Google Gemini API'sini resmi kÃ¼tÃ¼phane kullanarak Ã§aÄŸÄ±rÄ±r.
    Sohbet geÃ§miÅŸini (context) de iÅŸler.
    """
    if not GEMINI_API_KEY:
        print("Hata: Gemini API Ã§aÄŸrÄ±sÄ± denendi ancak GEMINI_API_KEY ayarlÄ± deÄŸil.")
        return "Hata: Gemini API anahtarÄ± sunucu tarafÄ±nda ayarlanmamÄ±ÅŸ."

    converted_history = []
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role and content:
                gemini_role = 'model' if role == 'assistant' else role
                if gemini_role in ['user', 'model']:
                    converted_history.append({'role': gemini_role, 'parts': [content]})
        print(f"Gemini iÃ§in dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ geÃ§miÅŸ (ilk 5): {converted_history[:5]}")
    else:
        print("Gemini iÃ§in geÃ§erli bir geÃ§miÅŸ gÃ¶nderilmedi.")

    try:
        default_max_output = 8192
        generation_config = {"temperature": 0.7, "top_p": 1.0, "top_k": 1, "max_output_tokens": default_max_output}
        safety_settings = [
            {"category": c, "threshold": "BLOCK_MEDIUM_AND_ABOVE"}
            for c in ["HARM_CATEGORY_HARASSMENT", "HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_SEXUALLY_EXPLICIT", "HARM_CATEGORY_DANGEROUS_CONTENT"]
        ]
        actual_model_name_for_api = model_id
        model = genai.GenerativeModel(model_name=actual_model_name_for_api, generation_config=generation_config, safety_settings=safety_settings)

        # Persona'yÄ± prompt'a ekleme (isteÄŸe baÄŸlÄ±)
        # full_prompt = f"Senin gÃ¶revin: {persona if persona else 'yardÄ±mcÄ± bir asistansÄ±n'}. KullanÄ±cÄ±nÄ±n mesajÄ±: {prompt}"

        chat = model.start_chat(history=converted_history)
        response = chat.send_message(prompt) # Sadece yeni kullanÄ±cÄ± mesajÄ±nÄ± gÃ¶nder

        return response.text.strip()

    except Exception as e:
        print(f"Gemini KÃ¼tÃ¼phane HatasÄ± (Model: {model_id}): {e}")
        error_message = str(e)
        if "API key not valid" in error_message: return "Gemini API hatasÄ±: GeÃ§ersiz API anahtarÄ±."
        elif "model" in error_message and ("not found" in error_message or "does not exist" in error_message or "permission denied" in error_message): return f"Gemini API hatasÄ±: '{model_id}' modeli bulunamadÄ± veya eriÅŸilemiyor."
        elif "User location is not supported" in error_message: return "Gemini API hatasÄ±: Konum desteklenmiyor."
        elif "RESOURCE_EXHAUSTED" in error_message or "quota" in error_message: return "Gemini API hatasÄ±: Kota aÅŸÄ±ldÄ±."
        elif "Safety settings triggered" in error_message or "blocked" in error_message:
            try: print(f"Engellenen iÃ§erik detayÄ±: {response.prompt_feedback}")
            except Exception: pass
            return "Gemini API hatasÄ±: GÃ¼venlik filtreleri tarafÄ±ndan engellendi."
        return f"Gemini API hatasÄ±: {error_message}"

def call_openrouter_api(prompt, model_id, persona="", history=None):
    """
    OpenRouter API'sini Ã§aÄŸÄ±rÄ±r.
    Sohbet geÃ§miÅŸini (context) de iÅŸler.
    """
    if not OPENROUTER_API_KEY:
        print("Hata: OpenRouter API Ã§aÄŸrÄ±sÄ± denendi ancak OPENROUTER_API_KEY ayarlÄ± deÄŸil.")
        return "Hata: OpenRouter API anahtarÄ± sunucu tarafÄ±nda ayarlanmamÄ±ÅŸ."

    api_url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {"Authorization": f"Bearer {OPENROUTER_API_KEY}", "Content-Type": "application/json"}

    messages_for_api = []
    # Sistem mesajÄ± olarak persona ekle
    if persona: messages_for_api.append({"role": "system", "content": f"Sen {persona}."})
    else: messages_for_api.append({"role": "system", "content": "Sen yardÄ±mcÄ± bir asistansÄ±n."})

    # GeÃ§miÅŸi ekle
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role in ['user', 'assistant'] and content:
               messages_for_api.append({"role": role, "content": content})
        print(f"OpenRouter iÃ§in gÃ¶nderilecek geÃ§miÅŸ (ilk 5): {messages_for_api[1:6]}")
    else:
        print("OpenRouter iÃ§in geÃ§erli bir geÃ§miÅŸ gÃ¶nderilmedi.")

    # Son kullanÄ±cÄ± mesajÄ±nÄ± ekle
    messages_for_api.append({"role": "user", "content": prompt})

    data = {"model": model_id, "messages": messages_for_api, "max_tokens": 2048, "temperature": 0.7}
    print(f"OpenRouter API isteÄŸi (ilk 5 mesaj): {json.dumps(data['messages'][:5], indent=2)}")

    try:
        response = requests.post(api_url, headers=headers, json=data, timeout=60)
        response.raise_for_status()
        result = response.json()
        ai_content = result.get("choices", [{}])[0].get("message", {}).get("content")
        if ai_content: return ai_content.strip()
        else:
            print(f"OpenRouter yanÄ±t formatÄ± beklenenden farklÄ± (Model: {model_id}): {result}")
            return "OpenRouter'dan geÃ§erli bir yanÄ±t alÄ±namadÄ±."

    except requests.exceptions.RequestException as e:
        print(f"OpenRouter API HatasÄ± (Model: {model_id}): {e}")
        error_detail = str(e)
        status_code = e.response.status_code if e.response is not None else None
        if e.response is not None:
            try: error_detail = e.response.json().get('error', {}).get('message', str(e))
            except ValueError: error_detail = e.response.text
        if status_code == 401: return "OpenRouter API hatasÄ±: GeÃ§ersiz API anahtarÄ±."
        if status_code == 402: return "OpenRouter API hatasÄ±: Kredi yetersiz."
        if status_code == 429: return "OpenRouter API hatasÄ±: HÄ±z limiti aÅŸÄ±ldÄ±."
        if status_code is not None and 400 <= status_code < 500 and ("model not found" in error_detail.lower() or "invalid model" in error_detail.lower()): return f"OpenRouter API hatasÄ±: '{model_id}' modeli bulunamadÄ±."
        if status_code == 400 and "context length" in error_detail.lower(): return "OpenRouter API hatasÄ±: Context limitini aÅŸÄ±yor."
        return f"OpenRouter API hatasÄ±: {error_detail} (Kod: {status_code})"
    except Exception as e:
        print(f"Beklenmedik Hata (OpenRouter - Model: {model_id}): {e}")
        return "OpenRouter yanÄ±tÄ± iÅŸlenirken hata."


# --- 10. API Endpoint'leri ---

# Karakter listesini dÃ¶ndÃ¼ren endpoint
@app.route('/api/characters', methods=['GET'])
def get_characters():
    """Drive'dan yÃ¼klenen karakter listesini JSON olarak dÃ¶ndÃ¼rÃ¼r."""
    # Her istekte listeyi yeniden yÃ¼kleyebiliriz (opsiyonel, performansa gÃ¶re karar verilir)
    # backend_characters = load_characters_from_drive(CHARACTER_JSON_PATH)
    print(f"/api/characters Ã§aÄŸrÄ±ldÄ±, {len(backend_characters)} karakter dÃ¶ndÃ¼rÃ¼lÃ¼yor.")
    return jsonify(backend_characters)

# Sohbet isteklerini iÅŸleyen endpoint
@app.route('/api/chat', methods=['POST'])
def chat_handler():
    """Frontend'den gelen POST isteklerini iÅŸler ve uygun AI API'sini Ã§aÄŸÄ±rÄ±r."""
    data = request.json
    if not data:
        print("Hata: BoÅŸ veya JSON olmayan istek alÄ±ndÄ±.")
        return jsonify({"error": "GeÃ§ersiz istek formatÄ±. JSON bekleniyor."}), 400

    user_message = data.get('message')
    model_id_from_frontend = data.get('modelId')
    history = data.get('history', [])
    character_name = data.get('characterName', 'Bilinmeyen Karakter') # Frontend karakter adÄ±nÄ± hala gÃ¶nderiyor
    persona_key = data.get('personaKey', 'default')
    custom_persona_text = data.get('customPersonaText', '')

    if not user_message or not model_id_from_frontend:
        print(f"Hata: Eksik bilgi. Gelen veri: {data}")
        return jsonify({"error": "Eksik bilgi: 'message' ve 'modelId' gerekli."}), 400

    print(f"Gelen istek: Model={model_id_from_frontend}, PersonaKey={persona_key}, Karakter={character_name}, GeÃ§miÅŸ Mesaj SayÄ±sÄ±={len(history)}")

    # Persona aÃ§Ä±klamasÄ±nÄ± belirle
    persona_description = ""
    if persona_key == 'custom' and custom_persona_text: persona_description = custom_persona_text
    elif persona_key == 'witty': persona_description = f"{character_name} adÄ±nda esprili bir arkadaÅŸsÄ±n."
    elif persona_key == 'wise': persona_description = f"{character_name} adÄ±nda bilge bir Ã¶ÄŸretmensin."
    else: persona_description = f"{character_name} adÄ±nda yardÄ±mcÄ± bir asistansÄ±n."

    ai_response = "Hata: Model iÅŸlenemedi veya desteklenmiyor."

    # Model ID'sine gÃ¶re yÃ¶nlendirme
    is_known_gemini = model_id_from_frontend in known_models_info and known_models_info[model_id_from_frontend]["provider"] == "google"
    is_likely_openrouter = "/" in model_id_from_frontend

    if is_known_gemini:
        if GEMINI_API_KEY:
            print(f"Google Gemini API Ã§aÄŸrÄ±lÄ±yor: Model={model_id_from_frontend}")
            ai_response = call_gemini_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            ai_response = "Hata: Gemini API anahtarÄ± ayarlanmamÄ±ÅŸ."
    elif is_likely_openrouter:
        if OPENROUTER_API_KEY:
            print(f"OpenRouter API Ã§aÄŸrÄ±lÄ±yor: Model={model_id_from_frontend}")
            ai_response = call_openrouter_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            ai_response = "Hata: OpenRouter API anahtarÄ± ayarlanmamÄ±ÅŸ."
    else:
        ai_response = f"Hata: Desteklenmeyen model ID formatÄ±: '{model_id_from_frontend}'."

    print(f"YanÄ±t gÃ¶nderiliyor: {ai_response[:100]}...")
    return jsonify({"reply": ai_response})

# --- YENÄ° ENDPOINT: SillyTavern KartÄ±nÄ± Formatla ve Kaydet ---
@app.route('/api/format_tavern_card', methods=['POST'])
def handle_format_and_save():
    """
    POST ile gelen SillyTavern JSON kartÄ±nÄ± alÄ±r,
    istenen formata dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r ve Drive'daki karakterler klasÃ¶rÃ¼ne kaydeder.
    """
    if not request.is_json:
        return jsonify({"error": "Ä°stek gÃ¶vdesi JSON formatÄ±nda olmalÄ±"}), 400

    # Karakter klasÃ¶rÃ¼nÃ¼n varlÄ±ÄŸÄ±nÄ± tekrar kontrol et
    if not os.path.isdir(CHARACTER_JSON_PATH):
         print(f"Hata: KayÄ±t klasÃ¶rÃ¼ bulunamadÄ±: {CHARACTER_JSON_PATH}")
         return jsonify({"error": f"Sunucu hatasÄ±: Karakter kayÄ±t klasÃ¶rÃ¼ bulunamadÄ± ({CHARACTER_JSON_PATH}). Drive baÄŸlantÄ±sÄ±nÄ± kontrol edin."}), 500

    try:
        original_card = request.get_json()

        # Opsiyonel: URL parametresinden varsayÄ±lan avatar al
        default_avatar_url = request.args.get('avatar_url', '')

        # KartÄ± yeni formata dÃ¶nÃ¼ÅŸtÃ¼r
        formatted_card = format_card_for_aichatdrive(original_card, default_avatar=default_avatar_url)

        if formatted_card is None:
            return jsonify({"error": "Kart verisi iÅŸlenemedi veya geÃ§ersiz. Girdi formatÄ±nÄ± veya karakter adÄ±nÄ± kontrol edin."}), 400

        # Kaydedilecek dosya adÄ±nÄ± oluÅŸtur
        safe_filename_base = sanitize_filename(formatted_card['name'])
        output_filename = f"{safe_filename_base}.json"
        output_filepath = os.path.join(CHARACTER_JSON_PATH, output_filename) # Hedef klasÃ¶rÃ¼ kullan

        # Yeni formatlanmÄ±ÅŸ JSON verisini dosyaya yaz
        try:
            with open(output_filepath, 'w', encoding='utf-8') as f:
                json.dump(formatted_card, f, indent=2, ensure_ascii=False)
            print(f"Kart baÅŸarÄ±yla kaydedildi: {output_filepath}")

            # BaÅŸarÄ±dan sonra karakter listesini GÃœNCELLE
            global backend_characters # Global listeyi deÄŸiÅŸtireceÄŸimizi belirtelim
            backend_characters = load_characters_from_drive(CHARACTER_JSON_PATH)
            print("Arka uÃ§ karakter listesi gÃ¼ncellendi.")

        except IOError as e:
            print(f"Dosya yazma hatasÄ±: {e}")
            return jsonify({"error": f"Dosya kaydedilemedi: {output_filepath}"}), 500
        except Exception as e:
            print(f"Dosya kaydetme sÄ±rasÄ±nda beklenmedik hata: {e}")
            return jsonify({"error": "Dosya kaydetme sÄ±rasÄ±nda bilinmeyen bir hata oluÅŸtu."}), 500

        # BaÅŸarÄ± mesajÄ± dÃ¶ndÃ¼r
        return jsonify({
            "message": "Kart baÅŸarÄ±yla formatlandÄ± ve kaydedildi.",
            "saved_path": output_filepath,
            "formatted_data": formatted_card
        }), 200

    except Exception as e:
        print(f"Genel sunucu hatasÄ± (/api/format_tavern_card): {e}")
        return jsonify({"error": f"Sunucu tarafÄ±nda beklenmedik bir hata oluÅŸtu: {str(e)}"}), 500


# --- 11. UygulamayÄ± ve Ngrok TÃ¼nelini BaÅŸlat ---
PORT = 5000

def run_flask():
    """Flask uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±r."""
    print(f"Flask uygulamasÄ± http://127.0.0.1:{PORT} adresinde baÅŸlatÄ±lÄ±yor...")
    # Colab'da genellikle host='0.0.0.0' kullanmak daha iyidir
    app.run(port=PORT, host='0.0.0.0', use_reloader=False, debug=False)

if __name__ == '__main__':
    try: ngrok.kill()
    except Exception as e: print(f"Mevcut ngrok iÅŸlemleri sonlandÄ±rÄ±lamadÄ± (sorun deÄŸil): {e}")

    try:
        if not NGROK_AUTHTOKEN:
             print("\nUYARI: Ngrok Authtoken ayarlanmadÄ±ÄŸÄ± iÃ§in Ngrok tÃ¼neli baÅŸlatÄ±lamÄ±yor.")
             # Ngrok olmadan da yerel olarak Ã§alÄ±ÅŸtÄ±rmayÄ± dene (Colab dÄ±ÅŸÄ± kullanÄ±m iÃ§in)
             print("\nFlask uygulamasÄ± (Drive Karakterleri & Context & Formatlama Destekli) baÅŸlatÄ±lÄ±yor...")
             print(f" * Drive'dan YÃ¼klenen Karakter SayÄ±sÄ±: {len(backend_characters)}")
             print(f"\nğŸš¨ API Endpoint'leri (Yerel):")
             print(f"   - Sohbet iÃ§in: http://127.0.0.1:{PORT}/api/chat")
             print(f"   - Karakter listesi iÃ§in: http://127.0.0.1:{PORT}/api/characters")
             print(f"   - Kart Formatlama iÃ§in: http://127.0.0.1:{PORT}/api/format_tavern_card")
             print("--------------------------------------------------------------------------\n")
             run_flask()
        else:
             public_url = ngrok.connect(PORT)
             print("--------------------------------------------------------------------------")
             print(f"âœ… Ngrok TÃ¼neli BaÅŸarÄ±yla OluÅŸturuldu!")
             print(f"   Public URL: {public_url}")
             print(f"   Bu URL, yerel Flask sunucunuza ({PORT}) yÃ¶nlendirir.")
             print("--------------------------------------------------------------------------")
             print("\nFlask uygulamasÄ± (Drive Karakterleri & Context & Formatlama Destekli) baÅŸlatÄ±lÄ±yor...")
             print(f" * Drive'dan YÃ¼klenen Karakter SayÄ±sÄ±: {len(backend_characters)}")
             print("\nğŸš¨ Ã–NEMLÄ°: Frontend uygulamanÄ±zdaki API URL'lerini gÃ¼ncelleyin:")
             print(f"   - Sohbet iÃ§in: {public_url}/api/chat")
             print(f"   - Karakter listesi iÃ§in: {public_url}/api/characters")
             print(f"   - Kart Formatlama iÃ§in: {public_url}/api/format_tavern_card") # YENÄ° ENDPOINT
             print("--------------------------------------------------------------------------\n")
             run_flask()

    except Exception as e:
        print("\nâŒ HATA: Ngrok tÃ¼neli baÅŸlatÄ±lÄ±rken veya Flask Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken ciddi bir hata oluÅŸtu.")
        print(f"Hata DetayÄ±: {e}")
        error_str = str(e).lower()
        if "authentication failed" in error_str or "authtoken" in error_str: print("-> Hata: Ngrok kimlik doÄŸrulamasÄ± baÅŸarÄ±sÄ±z. NGROK_AUTHTOKEN'Ä± kontrol edin.")
        elif "could not connect" in error_str: print("-> Hata: Ngrok servisine baÄŸlanÄ±lamadÄ±.")
        elif "port already in use" in error_str: print(f"-> Hata: {PORT} portu zaten kullanÄ±lÄ±yor.")
        else: print("-> Ngrok Authtoken'Ä± ve internet baÄŸlantÄ±sÄ±nÄ± kontrol edin.")

```

**NasÄ±l KullanÄ±lÄ±r:**

1.  Bu gÃ¼ncellenmiÅŸ kodu Colab'da Ã§alÄ±ÅŸtÄ±rÄ±n.
2.  Ngrok URL'si oluÅŸturulduÄŸunda, `/api/format_tavern_card` endpoint'ine (Ã¶rn: `http://xxxxxxxx.ngrok.io/api/format_tavern_card`) bir `POST` isteÄŸi gÃ¶nderin.
3.  Ä°steÄŸin gÃ¶vdesine (`body`) formatlamak istediÄŸiniz **orijinal SillyTavern kartÄ±nÄ±n JSON verisini** yapÄ±ÅŸtÄ±rÄ±n.
4.  Ä°steÄŸin `Content-Type` baÅŸlÄ±ÄŸÄ±nÄ±n `application/json` olduÄŸundan emin olun.
5.  BaÅŸarÄ±lÄ± olursa, kart istediÄŸiniz formata dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼p Google Drive'daki `MyDrive/Aichatdrive/characters/` klasÃ¶rÃ¼ne kaydedilecek ve API yanÄ±tÄ±nda kaydedilen dosyanÄ±n yolu belirtilecektir. AyrÄ±ca, yeni kart kaydedildikten sonra arka plandaki `backend_characters` listesi otomatik olarak gÃ¼ncellenir, bÃ¶ylece `/api/characters` endpoint'i Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda yeni eklenen karakter de listede gÃ¶rÃ¼n
