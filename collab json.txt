# -*- coding: utf-8 -*-

# --- 1. Gerekli Kütüphaneleri Yükle ---
# Flask: Web sunucusu framework'ü
# Flask-Cors: Tarayıcıların farklı kaynaklardan gelen isteklerine izin vermek için (Cross-Origin Resource Sharing)
# requests: Harici API'lere HTTP istekleri göndermek için
# pyngrok: Yerel Flask sunucusunu internete açmak için (Colab'da kullanışlı)
# google-generativeai: Google Gemini API'si için resmi Python kütüphanesi
!pip install Flask Flask-Cors requests pyngrok google-generativeai -q
print("Gerekli kütüphaneler yüklendi.")

# --- 2. Kütüphaneleri ve Modülleri İçe Aktar ---
import os
import requests
from flask import Flask, request, jsonify
from flask_cors import CORS
from pyngrok import ngrok, conf
import google.generativeai as genai
import threading # Flask'ı ayrı bir thread'de çalıştırmak için (Colab'da bazen gerekli)
import json # JSON işleme için
import glob # Dosya yolu eşleştirme için
from google.colab import drive # Google Drive bağlamak için
import re # Dosya adı ve ID temizleme için
import unicodedata # Türkçe karakterleri dönüştürmek için

# --- 3. Google Drive'ı Bağla ---
DRIVE_MOUNT_POINT = '/content/drive'
# Kullanıcının belirttiği alt klasör
DRIVE_CHAT_FOLDER = '/Aichatdrive' # Kullanıcının belirttiği klasör adı
# Karakter JSON dosyalarının bulunduğu varsayılan yol
CHARACTER_JSON_PATH = os.path.join(DRIVE_MOUNT_POINT, 'MyDrive', DRIVE_CHAT_FOLDER.strip('/'), 'characters') # MyDrive/Aichatdrive/characters

try:
    drive.mount(DRIVE_MOUNT_POINT)
    print(f"Google Drive başarıyla {DRIVE_MOUNT_POINT} adresine bağlandı.")
    # Karakter klasörünü oluştur (varsa hata vermez)
    os.makedirs(CHARACTER_JSON_PATH, exist_ok=True)
    print(f"Karakter klasörü kontrol edildi/oluşturuldu: {CHARACTER_JSON_PATH}")
    # Karakterleri yükleme fonksiyonu burada çağrılacak (aşağıda tanımlandı)

except Exception as e:
    print(f"Google Drive bağlanırken veya klasör oluşturulurken hata oluştu: {e}")
    print("Karakterler Drive'dan yüklenemeyecek veya kaydedilemeyecek.")
    # Hata durumunda boş liste ile devam et
    backend_characters = []


# --- 4. API Anahtarlarını ve Ngrok Token'ını Al ---
# Google Colab'ın Secrets (Gizli Anahtarlar) özelliğini kullanarak API anahtarlarını güvenli bir şekilde saklayın.
# Sol menüdeki anahtar (🔑) ikonuna tıklayarak şu isimlerle ekleyin:
# GEMINI_API_KEY, OPENROUTER_API_KEY, NGROK_AUTHTOKEN
try:
    from google.colab import userdata
    GEMINI_API_KEY = userdata.get('GEMINI_API_KEY')
    OPENROUTER_API_KEY = userdata.get('OPENROUTER_API_KEY') # OpenRouter anahtarını al
    NGROK_AUTHTOKEN = userdata.get('NGROK_AUTHTOKEN')
    print("API anahtarları ve Ngrok Authtoken Colab Secrets'tan başarıyla alındı.")

    # Gemini API'sini yapılandır
    if GEMINI_API_KEY:
        genai.configure(api_key=GEMINI_API_KEY)
        print("Google Gemini API başarıyla yapılandırıldı.")
    else:
        print("Uyarı: Colab Secrets'ta 'GEMINI_API_KEY' bulunamadı. Gemini modelleri çalışmayacak.")

    # Ngrok'u yapılandır (Ngrok tünelinin kimlik doğrulaması için)
    if NGROK_AUTHTOKEN:
        conf.get_default().auth_token = NGROK_AUTHTOKEN
        print("Ngrok Authtoken başarıyla ayarlandı.")
    else:
        print("Uyarı: Colab Secrets'ta 'NGROK_AUTHTOKEN' bulunamadı. Ngrok tüneli kısıtlı olabilir veya çalışmayabilir.")

    # OpenRouter anahtarının varlığını kontrol et
    if not OPENROUTER_API_KEY:
        print("Uyarı: Colab Secrets'ta 'OPENROUTER_API_KEY' bulunamadı. OpenRouter modelleri çalışmayacak.")

# Colab ortamında değilse veya userdata modülü yoksa
except ImportError:
    print("Google Colab ortamında değilsiniz veya 'userdata' modülü bulunamadı. API anahtarları manuel olarak ayarlanmalı veya ortam değişkenlerinden okunmalı.")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None
# Secrets'ta anahtar eksikse
except KeyError as e:
     print(f"Colab Secrets'ta eksik anahtar: {e}. Lütfen sol menüden (🔑) gerekli anahtarları ekleyin.")
     # Eksik anahtarları None olarak ayarla ki program devam edebilsin (ama ilgili API çalışmaz)
     if 'GEMINI_API_KEY' not in locals(): GEMINI_API_KEY = None
     if 'OPENROUTER_API_KEY' not in locals(): OPENROUTER_API_KEY = None
     if 'NGROK_AUTHTOKEN' not in locals(): NGROK_AUTHTOKEN = None
# Diğer beklenmedik hatalar
except Exception as e:
    print(f"API anahtarı veya Ngrok token yapılandırılırken genel bir hata oluştu: {e}")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None


# --- 5. Karakterleri Drive'dan Yükleme Fonksiyonu ---
def load_characters_from_drive(path):
    """
    Belirtilen yoldaki tüm .json dosyalarını okuyarak karakter listesini oluşturur.
    Her JSON dosyasının bir karakteri temsil ettiği varsayılır.
    JSON formatı: {"id": "...", "name": "...", "avatar": "...", "description": "...", "tags": [...], "isPremium": true/false}
    """
    characters = []
    # Klasörün varlığını tekrar kontrol et (Drive bağlantısı kopmuş olabilir)
    if not os.path.isdir(path):
        print(f"Uyarı: Karakter yükleme sırasında klasör bulunamadı: {path}")
        return []

    json_files = glob.glob(os.path.join(path, '*.json')) # Klasördeki tüm .json dosyalarını bul
    print(f"Bulunan JSON dosyaları ({len(json_files)} adet): {json_files}")

    if not json_files:
        print(f"Uyarı: '{path}' içinde hiç JSON dosyası bulunamadı.")
        return []

    for file_path in json_files:
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                char_data = json.load(f)

                # Gerekli alanların varlığını ve türünü kontrol et (basit kontrol)
                if all(k in char_data for k in ['id', 'name', 'avatar', 'description', 'tags', 'isPremium']) and \
                   isinstance(char_data['tags'], list) and \
                   isinstance(char_data['isPremium'], bool):
                    characters.append(char_data)
                    print(f"Başarıyla yüklendi: {char_data.get('name')} ({os.path.basename(file_path)})")
                else:
                    print(f"Uyarı: '{os.path.basename(file_path)}' dosyasında eksik veya yanlış formatta alanlar var. Atlanıyor.")

        except json.JSONDecodeError:
            print(f"Hata: '{os.path.basename(file_path)}' dosyası geçerli bir JSON değil. Atlanıyor.")
        except Exception as e:
            print(f"Hata: '{os.path.basename(file_path)}' dosyası okunurken hata oluştu: {e}. Atlanıyor.")

    print(f"Toplam {len(characters)} karakter Drive'dan yüklendi.")
    return characters

# Drive bağlandıktan ve klasör kontrol edildikten sonra karakterleri yükle
if 'backend_characters' not in locals(): # Eğer Drive bağlanırken hata olduysa bu değişken tanımlanmamış olabilir
     backend_characters = []
if os.path.isdir(CHARACTER_JSON_PATH): # Sadece klasör varsa yüklemeyi dene
    backend_characters = load_characters_from_drive(CHARACTER_JSON_PATH)
else:
    # Klasör yoksa yükleme zaten yapılamaz, boş liste ile devam edilir
    if 'backend_characters' not in locals(): # Hata durumunda tanımlanmamış olabilir
        backend_characters = []
    print(f"Uyarı: Karakter klasörü '{CHARACTER_JSON_PATH}' bulunamadığı için karakter yüklenemedi.")


# --- 6. Yardımcı Fonksiyonlar (Formatlama ve Temizleme) ---

def format_card_for_aichatdrive(original_card_data, default_avatar=""):
    """
    SillyTavern kartını Aichatdrive formatına dönüştürür.
    """
    if not isinstance(original_card_data, dict):
        print("Hata: Girdi bir sözlük olmalıdır.")
        return None

    data = original_card_data.get('data', original_card_data) # Handle V2 structure

    new_format = {}

    # --- Alanları Çıkar veya Oluştur ---
    char_name = data.get('name', data.get('char_name', ''))
    if not char_name:
        print("Hata: Karakter adı bulunamadı.")
        return None # İsimsiz kart olmaz

    # ID Oluşturma
    normalized_name = unicodedata.normalize('NFKD', char_name).encode('ASCII', 'ignore').decode('ASCII')
    sanitized_id = re.sub(r'\s+', '-', normalized_name.lower())
    sanitized_id = re.sub(r'[^\w\-]', '', sanitized_id)
    new_format['id'] = sanitized_id if sanitized_id else "default-id"

    new_format['name'] = char_name

    # Avatar: Önce data['avatar'] kontrol et, sonra parametreye bak
    avatar_url = data.get('avatar') # Try finding it within 'data'
    # If not found in 'data' AND 'data' structure was used, try checking root level as fallback
    if not avatar_url and original_card_data.get('data') is data:
        avatar_url = original_card_data.get('avatar')

    new_format['avatar'] = avatar_url if avatar_url else default_avatar # Use found URL or default

    # Description
    description_text = data.get('description', data.get('char_persona', ''))
    new_format['description'] = description_text

    # Tags
    new_format['tags'] = data.get('tags', [])
    if not isinstance(new_format['tags'], list):
        new_format['tags'] = []

    # isPremium
    new_format['isPremium'] = data.get('isPremium', False) # Check if it exists in input, default false

    return new_format

def sanitize_filename(name):
    """İsimden güvenli bir dosya adı oluşturur."""
    # Türkçe karakterleri dönüştür
    name = unicodedata.normalize('NFKD', name).encode('ASCII', 'ignore').decode('ASCII')
    # Geçersiz karakterleri kaldır veya değiştir (boşluk yerine _)
    name = re.sub(r'[^\w\.\-]', '_', name)
    # Çoklu alt çizgileri teke indir
    name = re.sub(r'_+', '_', name)
    # Başta veya sonda olabilecek alt çizgileri kaldır
    name = name.strip('_')
    return name if name else "unnamed_character"


# --- 7. Flask Uygulamasını Başlat ---
app = Flask(__name__)
# CORS(app) tüm kaynaklardan gelen isteklere izin verir.
CORS(app)

# --- 8. Bilinen Modeller (Bilgi amaçlı) ---
# Bu liste API yönlendirmesi için kullanılabilir.
known_models_info = {
    # Gemini Modelleri (Google)
    "gemini-pro": { "name": "Gemini 1.0 Pro (Google)", "provider": "google" },
    "gemini-1.5-flash-latest": { "name": "Gemini 1.5 Flash (Google)", "provider": "google" },
    # OpenRouter Örnekleri
    "openai/gpt-4o-mini": { "name": "GPT-4o Mini (OpenRouter)", "provider": "openrouter" },
    "anthropic/claude-3-haiku-20240307": { "name": "Claude 3 Haiku (OpenRouter)", "provider": "openrouter" },
    "mistralai/mistral-7b-instruct": { "name": "Mistral 7B Instruct (OpenRouter)", "provider": "openrouter" },
    "google/gemini-pro": { "name": "Gemini Pro (OpenRouter)", "provider": "openrouter" },
    "gryphe/mythomax-l2-13b": { "name": "MythoMax L2 13B (OpenRouter)", "provider": "openrouter", "isPremium": True }
}


# --- 9. AI API Çağrı Fonksiyonları ---

def call_gemini_api(prompt, model_id="gemini-pro", persona="", history=None):
    """
    Google Gemini API'sini resmi kütüphane kullanarak çağırır.
    Sohbet geçmişini (context) de işler.
    """
    if not GEMINI_API_KEY:
        print("Hata: Gemini API çağrısı denendi ancak GEMINI_API_KEY ayarlı değil.")
        return "Hata: Gemini API anahtarı sunucu tarafında ayarlanmamış."

    converted_history = []
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role and content:
                gemini_role = 'model' if role == 'assistant' else role
                if gemini_role in ['user', 'model']:
                    converted_history.append({'role': gemini_role, 'parts': [content]})
        print(f"Gemini için dönüştürülmüş geçmiş (ilk 5): {converted_history[:5]}")
    else:
        print("Gemini için geçerli bir geçmiş gönderilmedi.")

    try:
        default_max_output = 8192
        generation_config = {"temperature": 0.7, "top_p": 1.0, "top_k": 1, "max_output_tokens": default_max_output}
        safety_settings = [
            {"category": c, "threshold": "BLOCK_MEDIUM_AND_ABOVE"}
            for c in ["HARM_CATEGORY_HARASSMENT", "HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_SEXUALLY_EXPLICIT", "HARM_CATEGORY_DANGEROUS_CONTENT"]
        ]
        actual_model_name_for_api = model_id
        model = genai.GenerativeModel(model_name=actual_model_name_for_api, generation_config=generation_config, safety_settings=safety_settings)

        # Persona'yı prompt'a ekleme (isteğe bağlı)
        # full_prompt = f"Senin görevin: {persona if persona else 'yardımcı bir asistansın'}. Kullanıcının mesajı: {prompt}"

        chat = model.start_chat(history=converted_history)
        response = chat.send_message(prompt) # Sadece yeni kullanıcı mesajını gönder

        return response.text.strip()

    except Exception as e:
        print(f"Gemini Kütüphane Hatası (Model: {model_id}): {e}")
        error_message = str(e)
        if "API key not valid" in error_message: return "Gemini API hatası: Geçersiz API anahtarı."
        elif "model" in error_message and ("not found" in error_message or "does not exist" in error_message or "permission denied" in error_message): return f"Gemini API hatası: '{model_id}' modeli bulunamadı veya erişilemiyor."
        elif "User location is not supported" in error_message: return "Gemini API hatası: Konum desteklenmiyor."
        elif "RESOURCE_EXHAUSTED" in error_message or "quota" in error_message: return "Gemini API hatası: Kota aşıldı."
        elif "Safety settings triggered" in error_message or "blocked" in error_message:
            try: print(f"Engellenen içerik detayı: {response.prompt_feedback}")
            except Exception: pass
            return "Gemini API hatası: Güvenlik filtreleri tarafından engellendi."
        return f"Gemini API hatası: {error_message}"

def call_openrouter_api(prompt, model_id, persona="", history=None):
    """
    OpenRouter API'sini çağırır.
    Sohbet geçmişini (context) de işler.
    """
    if not OPENROUTER_API_KEY:
        print("Hata: OpenRouter API çağrısı denendi ancak OPENROUTER_API_KEY ayarlı değil.")
        return "Hata: OpenRouter API anahtarı sunucu tarafında ayarlanmamış."

    api_url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {"Authorization": f"Bearer {OPENROUTER_API_KEY}", "Content-Type": "application/json"}

    messages_for_api = []
    # Sistem mesajı olarak persona ekle
    if persona: messages_for_api.append({"role": "system", "content": f"Sen {persona}."})
    else: messages_for_api.append({"role": "system", "content": "Sen yardımcı bir asistansın."})

    # Geçmişi ekle
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role in ['user', 'assistant'] and content:
               messages_for_api.append({"role": role, "content": content})
        print(f"OpenRouter için gönderilecek geçmiş (ilk 5): {messages_for_api[1:6]}")
    else:
        print("OpenRouter için geçerli bir geçmiş gönderilmedi.")

    # Son kullanıcı mesajını ekle
    messages_for_api.append({"role": "user", "content": prompt})

    data = {"model": model_id, "messages": messages_for_api, "max_tokens": 2048, "temperature": 0.7}
    print(f"OpenRouter API isteği (ilk 5 mesaj): {json.dumps(data['messages'][:5], indent=2)}")

    try:
        response = requests.post(api_url, headers=headers, json=data, timeout=60)
        response.raise_for_status()
        result = response.json()
        ai_content = result.get("choices", [{}])[0].get("message", {}).get("content")
        if ai_content: return ai_content.strip()
        else:
            print(f"OpenRouter yanıt formatı beklenenden farklı (Model: {model_id}): {result}")
            return "OpenRouter'dan geçerli bir yanıt alınamadı."

    except requests.exceptions.RequestException as e:
        print(f"OpenRouter API Hatası (Model: {model_id}): {e}")
        error_detail = str(e)
        status_code = e.response.status_code if e.response is not None else None
        if e.response is not None:
            try: error_detail = e.response.json().get('error', {}).get('message', str(e))
            except ValueError: error_detail = e.response.text
        if status_code == 401: return "OpenRouter API hatası: Geçersiz API anahtarı."
        if status_code == 402: return "OpenRouter API hatası: Kredi yetersiz."
        if status_code == 429: return "OpenRouter API hatası: Hız limiti aşıldı."
        if status_code is not None and 400 <= status_code < 500 and ("model not found" in error_detail.lower() or "invalid model" in error_detail.lower()): return f"OpenRouter API hatası: '{model_id}' modeli bulunamadı."
        if status_code == 400 and "context length" in error_detail.lower(): return "OpenRouter API hatası: Context limitini aşıyor."
        return f"OpenRouter API hatası: {error_detail} (Kod: {status_code})"
    except Exception as e:
        print(f"Beklenmedik Hata (OpenRouter - Model: {model_id}): {e}")
        return "OpenRouter yanıtı işlenirken hata."


# --- 10. API Endpoint'leri ---

# Karakter listesini döndüren endpoint
@app.route('/api/characters', methods=['GET'])
def get_characters():
    """Drive'dan yüklenen karakter listesini JSON olarak döndürür."""
    # Her istekte listeyi yeniden yükleyebiliriz (opsiyonel, performansa göre karar verilir)
    # backend_characters = load_characters_from_drive(CHARACTER_JSON_PATH)
    print(f"/api/characters çağrıldı, {len(backend_characters)} karakter döndürülüyor.")
    return jsonify(backend_characters)

# Sohbet isteklerini işleyen endpoint
@app.route('/api/chat', methods=['POST'])
def chat_handler():
    """Frontend'den gelen POST isteklerini işler ve uygun AI API'sini çağırır."""
    data = request.json
    if not data:
        print("Hata: Boş veya JSON olmayan istek alındı.")
        return jsonify({"error": "Geçersiz istek formatı. JSON bekleniyor."}), 400

    user_message = data.get('message')
    model_id_from_frontend = data.get('modelId')
    history = data.get('history', [])
    character_name = data.get('characterName', 'Bilinmeyen Karakter') # Frontend karakter adını hala gönderiyor
    persona_key = data.get('personaKey', 'default')
    custom_persona_text = data.get('customPersonaText', '')

    if not user_message or not model_id_from_frontend:
        print(f"Hata: Eksik bilgi. Gelen veri: {data}")
        return jsonify({"error": "Eksik bilgi: 'message' ve 'modelId' gerekli."}), 400

    print(f"Gelen istek: Model={model_id_from_frontend}, PersonaKey={persona_key}, Karakter={character_name}, Geçmiş Mesaj Sayısı={len(history)}")

    # Persona açıklamasını belirle
    persona_description = ""
    if persona_key == 'custom' and custom_persona_text: persona_description = custom_persona_text
    elif persona_key == 'witty': persona_description = f"{character_name} adında esprili bir arkadaşsın."
    elif persona_key == 'wise': persona_description = f"{character_name} adında bilge bir öğretmensin."
    else: persona_description = f"{character_name} adında yardımcı bir asistansın."

    ai_response = "Hata: Model işlenemedi veya desteklenmiyor."

    # Model ID'sine göre yönlendirme
    is_known_gemini = model_id_from_frontend in known_models_info and known_models_info[model_id_from_frontend]["provider"] == "google"
    is_likely_openrouter = "/" in model_id_from_frontend

    if is_known_gemini:
        if GEMINI_API_KEY:
            print(f"Google Gemini API çağrılıyor: Model={model_id_from_frontend}")
            ai_response = call_gemini_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            ai_response = "Hata: Gemini API anahtarı ayarlanmamış."
    elif is_likely_openrouter:
        if OPENROUTER_API_KEY:
            print(f"OpenRouter API çağrılıyor: Model={model_id_from_frontend}")
            ai_response = call_openrouter_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            ai_response = "Hata: OpenRouter API anahtarı ayarlanmamış."
    else:
        ai_response = f"Hata: Desteklenmeyen model ID formatı: '{model_id_from_frontend}'."

    print(f"Yanıt gönderiliyor: {ai_response[:100]}...")
    return jsonify({"reply": ai_response})

# --- YENİ ENDPOINT: SillyTavern Kartını Formatla ve Kaydet ---
@app.route('/api/format_tavern_card', methods=['POST'])
def handle_format_and_save():
    """
    POST ile gelen SillyTavern JSON kartını alır,
    istenen formata dönüştürür ve Drive'daki karakterler klasörüne kaydeder.
    """
    if not request.is_json:
        return jsonify({"error": "İstek gövdesi JSON formatında olmalı"}), 400

    # Karakter klasörünün varlığını tekrar kontrol et
    if not os.path.isdir(CHARACTER_JSON_PATH):
         print(f"Hata: Kayıt klasörü bulunamadı: {CHARACTER_JSON_PATH}")
         return jsonify({"error": f"Sunucu hatası: Karakter kayıt klasörü bulunamadı ({CHARACTER_JSON_PATH}). Drive bağlantısını kontrol edin."}), 500

    try:
        original_card = request.get_json()

        # Opsiyonel: URL parametresinden varsayılan avatar al
        default_avatar_url = request.args.get('avatar_url', '')

        # Kartı yeni formata dönüştür
        formatted_card = format_card_for_aichatdrive(original_card, default_avatar=default_avatar_url)

        if formatted_card is None:
            return jsonify({"error": "Kart verisi işlenemedi veya geçersiz. Girdi formatını veya karakter adını kontrol edin."}), 400

        # Kaydedilecek dosya adını oluştur
        safe_filename_base = sanitize_filename(formatted_card['name'])
        output_filename = f"{safe_filename_base}.json"
        output_filepath = os.path.join(CHARACTER_JSON_PATH, output_filename) # Hedef klasörü kullan

        # Yeni formatlanmış JSON verisini dosyaya yaz
        try:
            with open(output_filepath, 'w', encoding='utf-8') as f:
                json.dump(formatted_card, f, indent=2, ensure_ascii=False)
            print(f"Kart başarıyla kaydedildi: {output_filepath}")

            # Başarıdan sonra karakter listesini GÜNCELLE
            global backend_characters # Global listeyi değiştireceğimizi belirtelim
            backend_characters = load_characters_from_drive(CHARACTER_JSON_PATH)
            print("Arka uç karakter listesi güncellendi.")

        except IOError as e:
            print(f"Dosya yazma hatası: {e}")
            return jsonify({"error": f"Dosya kaydedilemedi: {output_filepath}"}), 500
        except Exception as e:
            print(f"Dosya kaydetme sırasında beklenmedik hata: {e}")
            return jsonify({"error": "Dosya kaydetme sırasında bilinmeyen bir hata oluştu."}), 500

        # Başarı mesajı döndür
        return jsonify({
            "message": "Kart başarıyla formatlandı ve kaydedildi.",
            "saved_path": output_filepath,
            "formatted_data": formatted_card
        }), 200

    except Exception as e:
        print(f"Genel sunucu hatası (/api/format_tavern_card): {e}")
        return jsonify({"error": f"Sunucu tarafında beklenmedik bir hata oluştu: {str(e)}"}), 500


# --- 11. Uygulamayı ve Ngrok Tünelini Başlat ---
PORT = 5000

def run_flask():
    """Flask uygulamasını çalıştırır."""
    print(f"Flask uygulaması http://127.0.0.1:{PORT} adresinde başlatılıyor...")
    # Colab'da genellikle host='0.0.0.0' kullanmak daha iyidir
    app.run(port=PORT, host='0.0.0.0', use_reloader=False, debug=False)

if __name__ == '__main__':
    try: ngrok.kill()
    except Exception as e: print(f"Mevcut ngrok işlemleri sonlandırılamadı (sorun değil): {e}")

    try:
        if not NGROK_AUTHTOKEN:
             print("\nUYARI: Ngrok Authtoken ayarlanmadığı için Ngrok tüneli başlatılamıyor.")
             # Ngrok olmadan da yerel olarak çalıştırmayı dene (Colab dışı kullanım için)
             print("\nFlask uygulaması (Drive Karakterleri & Context & Formatlama Destekli) başlatılıyor...")
             print(f" * Drive'dan Yüklenen Karakter Sayısı: {len(backend_characters)}")
             print(f"\n🚨 API Endpoint'leri (Yerel):")
             print(f"   - Sohbet için: http://127.0.0.1:{PORT}/api/chat")
             print(f"   - Karakter listesi için: http://127.0.0.1:{PORT}/api/characters")
             print(f"   - Kart Formatlama için: http://127.0.0.1:{PORT}/api/format_tavern_card")
             print("--------------------------------------------------------------------------\n")
             run_flask()
        else:
             public_url = ngrok.connect(PORT)
             print("--------------------------------------------------------------------------")
             print(f"✅ Ngrok Tüneli Başarıyla Oluşturuldu!")
             print(f"   Public URL: {public_url}")
             print(f"   Bu URL, yerel Flask sunucunuza ({PORT}) yönlendirir.")
             print("--------------------------------------------------------------------------")
             print("\nFlask uygulaması (Drive Karakterleri & Context & Formatlama Destekli) başlatılıyor...")
             print(f" * Drive'dan Yüklenen Karakter Sayısı: {len(backend_characters)}")
             print("\n🚨 ÖNEMLİ: Frontend uygulamanızdaki API URL'lerini güncelleyin:")
             print(f"   - Sohbet için: {public_url}/api/chat")
             print(f"   - Karakter listesi için: {public_url}/api/characters")
             print(f"   - Kart Formatlama için: {public_url}/api/format_tavern_card") # YENİ ENDPOINT
             print("--------------------------------------------------------------------------\n")
             run_flask()

    except Exception as e:
        print("\n❌ HATA: Ngrok tüneli başlatılırken veya Flask çalıştırılırken ciddi bir hata oluştu.")
        print(f"Hata Detayı: {e}")
        error_str = str(e).lower()
        if "authentication failed" in error_str or "authtoken" in error_str: print("-> Hata: Ngrok kimlik doğrulaması başarısız. NGROK_AUTHTOKEN'ı kontrol edin.")
        elif "could not connect" in error_str: print("-> Hata: Ngrok servisine bağlanılamadı.")
        elif "port already in use" in error_str: print(f"-> Hata: {PORT} portu zaten kullanılıyor.")
        else: print("-> Ngrok Authtoken'ı ve internet bağlantısını kontrol edin.")

```

**Nasıl Kullanılır:**

1.  Bu güncellenmiş kodu Colab'da çalıştırın.
2.  Ngrok URL'si oluşturulduğunda, `/api/format_tavern_card` endpoint'ine (örn: `http://xxxxxxxx.ngrok.io/api/format_tavern_card`) bir `POST` isteği gönderin.
3.  İsteğin gövdesine (`body`) formatlamak istediğiniz **orijinal SillyTavern kartının JSON verisini** yapıştırın.
4.  İsteğin `Content-Type` başlığının `application/json` olduğundan emin olun.
5.  Başarılı olursa, kart istediğiniz formata dönüştürülüp Google Drive'daki `MyDrive/Aichatdrive/characters/` klasörüne kaydedilecek ve API yanıtında kaydedilen dosyanın yolu belirtilecektir. Ayrıca, yeni kart kaydedildikten sonra arka plandaki `backend_characters` listesi otomatik olarak güncellenir, böylece `/api/characters` endpoint'i çağrıldığında yeni eklenen karakter de listede görün
