# -*- coding: utf-8 -*-

# --- 1. Gerekli KÃ¼tÃ¼phaneleri YÃ¼kle ---
# Flask: Web sunucusu framework'Ã¼
# Flask-Cors: TarayÄ±cÄ±larÄ±n farklÄ± kaynaklardan gelen isteklerine izin vermek iÃ§in (Cross-Origin Resource Sharing)
# requests: Harici API'lere HTTP istekleri gÃ¶ndermek iÃ§in
# pyngrok: Yerel Flask sunucusunu internete aÃ§mak iÃ§in (Colab'da kullanÄ±ÅŸlÄ±)
# google-generativeai: Google Gemini API'si iÃ§in resmi Python kÃ¼tÃ¼phanesi
!pip install Flask Flask-Cors requests pyngrok google-generativeai -q
print("Gerekli kÃ¼tÃ¼phaneler yÃ¼klendi.")

# --- 2. KÃ¼tÃ¼phaneleri ve ModÃ¼lleri Ä°Ã§e Aktar ---
import os
import requests
from flask import Flask, request, jsonify
from flask_cors import CORS
from pyngrok import ngrok, conf
import google.generativeai as genai
import threading # Flask'Ä± ayrÄ± bir thread'de Ã§alÄ±ÅŸtÄ±rmak iÃ§in (Colab'da bazen gerekli)
import json # JSON iÅŸleme iÃ§in

# --- 3. API AnahtarlarÄ±nÄ± ve Ngrok Token'Ä±nÄ± Al ---
# Google Colab'Ä±n Secrets (Gizli Anahtarlar) Ã¶zelliÄŸini kullanarak API anahtarlarÄ±nÄ± gÃ¼venli bir ÅŸekilde saklayÄ±n.
# Sol menÃ¼deki anahtar (ğŸ”‘) ikonuna tÄ±klayarak ÅŸu isimlerle ekleyin:
# GEMINI_API_KEY, OPENROUTER_API_KEY, NGROK_AUTHTOKEN
try:
    from google.colab import userdata
    GEMINI_API_KEY = userdata.get('GEMINI_API_KEY')
    OPENROUTER_API_KEY = userdata.get('OPENROUTER_API_KEY') # OpenRouter anahtarÄ±nÄ± al
    NGROK_AUTHTOKEN = userdata.get('NGROK_AUTHTOKEN')
    print("API anahtarlarÄ± ve Ngrok Authtoken Colab Secrets'tan baÅŸarÄ±yla alÄ±ndÄ±.")

    # Gemini API'sini yapÄ±landÄ±r
    if GEMINI_API_KEY:
        genai.configure(api_key=GEMINI_API_KEY)
        print("Google Gemini API baÅŸarÄ±yla yapÄ±landÄ±rÄ±ldÄ±.")
    else:
        print("UyarÄ±: Colab Secrets'ta 'GEMINI_API_KEY' bulunamadÄ±. Gemini modelleri Ã§alÄ±ÅŸmayacak.")

    # Ngrok'u yapÄ±landÄ±r (Ngrok tÃ¼nelinin kimlik doÄŸrulamasÄ± iÃ§in)
    if NGROK_AUTHTOKEN:
        conf.get_default().auth_token = NGROK_AUTHTOKEN
        print("Ngrok Authtoken baÅŸarÄ±yla ayarlandÄ±.")
    else:
        print("UyarÄ±: Colab Secrets'ta 'NGROK_AUTHTOKEN' bulunamadÄ±. Ngrok tÃ¼neli kÄ±sÄ±tlÄ± olabilir veya Ã§alÄ±ÅŸmayabilir.")

    # OpenRouter anahtarÄ±nÄ±n varlÄ±ÄŸÄ±nÄ± kontrol et
    if not OPENROUTER_API_KEY:
        print("UyarÄ±: Colab Secrets'ta 'OPENROUTER_API_KEY' bulunamadÄ±. OpenRouter modelleri Ã§alÄ±ÅŸmayacak.")

# Colab ortamÄ±nda deÄŸilse veya userdata modÃ¼lÃ¼ yoksa
except ImportError:
    print("Google Colab ortamÄ±nda deÄŸilsiniz veya 'userdata' modÃ¼lÃ¼ bulunamadÄ±. API anahtarlarÄ± manuel olarak ayarlanmalÄ± veya ortam deÄŸiÅŸkenlerinden okunmalÄ±.")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None
# Secrets'ta anahtar eksikse
except KeyError as e:
      print(f"Colab Secrets'ta eksik anahtar: {e}. LÃ¼tfen sol menÃ¼den (ğŸ”‘) gerekli anahtarlarÄ± ekleyin.")
      # Eksik anahtarlarÄ± None olarak ayarla ki program devam edebilsin (ama ilgili API Ã§alÄ±ÅŸmaz)
      if 'GEMINI_API_KEY' not in locals(): GEMINI_API_KEY = None
      if 'OPENROUTER_API_KEY' not in locals(): OPENROUTER_API_KEY = None
      if 'NGROK_AUTHTOKEN' not in locals(): NGROK_AUTHTOKEN = None
# DiÄŸer beklenmedik hatalar
except Exception as e:
    print(f"API anahtarÄ± veya Ngrok token yapÄ±landÄ±rÄ±lÄ±rken genel bir hata oluÅŸtu: {e}")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None


# --- 4. Flask UygulamasÄ±nÄ± BaÅŸlat ---
app = Flask(__name__)
# CORS(app) tÃ¼m kaynaklardan gelen isteklere izin verir.
# Daha gÃ¼venli bir yapÄ±landÄ±rma iÃ§in origin'leri belirtebilirsiniz: CORS(app, resources={r"/api/*": {"origins": "YOUR_FRONTEND_URL"}})
CORS(app)

# --- 5. Bilinen Modeller (Bilgi amaÃ§lÄ±, katÄ± kontrol iÃ§in deÄŸil) ---
# Bu sÃ¶zlÃ¼k, hangi model ID'sinin hangi saÄŸlayÄ±cÄ±ya ait olduÄŸunu hÄ±zlÄ±ca anlamak iÃ§in kullanÄ±labilir.
# Ancak API yÃ¶nlendirme mantÄ±ÄŸÄ± doÄŸrudan model ID formatÄ±na (Ã¶rn: '/' iÃ§eriyor mu?) bakÄ±yor.
known_models_info = {
    # Gemini Modelleri (Google)
    "gemini-pro": { "name": "Gemini 1.0 Pro (Google)", "provider": "google" },
    "gemini-1.5-flash-latest": { "name": "Gemini 1.5 Flash (Google)", "provider": "google" },
    # OpenRouter Ã¼zerinden eriÅŸilebilen Ã¶rnek modeller
    # OpenRouter model ID'leri genellikle "saÄŸlayÄ±cÄ±/model-adÄ±" formatÄ±ndadÄ±r.
    "openai/gpt-4o-mini": { "name": "GPT-4o Mini (OpenRouter)", "provider": "openrouter" },
    "anthropic/claude-3-haiku-20240307": { "name": "Claude 3 Haiku (OpenRouter)", "provider": "openrouter" },
    "mistralai/mistral-7b-instruct": { "name": "Mistral 7B Instruct (OpenRouter)", "provider": "openrouter" },
    "google/gemini-pro": { "name": "Gemini Pro (OpenRouter)", "provider": "openrouter" }, # Gemini'ye OpenRouter Ã¼zerinden de eriÅŸilebilir
    "gryphe/mythomax-l2-13b": { "name": "MythoMax L2 13B (OpenRouter)", "provider": "openrouter", "isPremium": True } # Ã–rnek: Premium model bilgisi
}


# --- 6. AI API Ã‡aÄŸrÄ± FonksiyonlarÄ± ---

def call_gemini_api(prompt, model_id="gemini-pro", persona="", history=None):
    """
    Google Gemini API'sini resmi kÃ¼tÃ¼phane kullanarak Ã§aÄŸÄ±rÄ±r.
    Sohbet geÃ§miÅŸini (context) de iÅŸler.
    """
    if not GEMINI_API_KEY:
        print("Hata: Gemini API Ã§aÄŸrÄ±sÄ± denendi ancak GEMINI_API_KEY ayarlÄ± deÄŸil.")
        return "Hata: Gemini API anahtarÄ± sunucu tarafÄ±nda ayarlanmamÄ±ÅŸ."

    # Gelen geÃ§miÅŸi Gemini formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼r: [{'role': 'user'/'model', 'parts': [text]}]
    # Frontend'den gelen 'assistant' rolÃ¼nÃ¼ 'model' olarak deÄŸiÅŸtir.
    converted_history = []
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role and content:
                # Gemini API 'assistant' yerine 'model' rolÃ¼nÃ¼ bekler
                gemini_role = 'model' if role == 'assistant' else role
                if gemini_role in ['user', 'model']: # Sadece geÃ§erli rolleri ekle
                    converted_history.append({'role': gemini_role, 'parts': [content]})
        print(f"Gemini iÃ§in dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ geÃ§miÅŸ (ilk 5): {converted_history[:5]}")
    else:
         print("Gemini iÃ§in geÃ§erli bir geÃ§miÅŸ gÃ¶nderilmedi.")


    try:
        # VarsayÄ±lan Ã¼retim yapÄ±landÄ±rmasÄ±
        default_max_output = 8192
        generation_config = {
            "temperature": 0.7,
            "top_p": 1.0,
            "top_k": 1,
            "max_output_tokens": default_max_output
        }
        # GÃ¼venlik ayarlarÄ±
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
        ]

        actual_model_name_for_api = model_id
        model = genai.GenerativeModel(
            model_name=actual_model_name_for_api,
            generation_config=generation_config,
            safety_settings=safety_settings
        )

        # Persona bilgisini prompt'a ekle (isteÄŸe baÄŸlÄ±, sistem mesajÄ± gibi dÃ¼ÅŸÃ¼nÃ¼lebilir)
        # Veya persona'yÄ± geÃ§miÅŸin baÅŸÄ±na bir sistem mesajÄ± olarak ekleyebilirsiniz.
        # Åimdilik prompt'a ekliyoruz.
        full_prompt = f"Senin gÃ¶revin: {persona if persona else 'yardÄ±mcÄ± bir asistansÄ±n'}. KullanÄ±cÄ±nÄ±n mesajÄ±: {prompt}"

        # Sohbeti geÃ§miÅŸle baÅŸlat
        # Ã–NEMLÄ°: Gemini kÃ¼tÃ¼phanesi history'yi doÄŸrudan `start_chat` iÃ§inde alÄ±r.
        # EÄŸer `send_message` kullanacaksak, prompt'u geÃ§miÅŸin sonuna eklememiz gerekebilir.
        # `start_chat` kullanmak daha temiz gÃ¶rÃ¼nÃ¼yor.
        chat = model.start_chat(history=converted_history) # DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ geÃ§miÅŸi kullan
        response = chat.send_message(prompt) # Sadece yeni mesajÄ± gÃ¶nder

        # YanÄ±tÄ± temizleyip dÃ¶ndÃ¼r
        return response.text.strip()

    # Hata yakalama
    except Exception as e:
        print(f"Gemini KÃ¼tÃ¼phane HatasÄ± (Model: {model_id}): {e}")
        error_message = str(e)
        # YaygÄ±n hatalar iÃ§in daha aÃ§Ä±klayÄ±cÄ± mesajlar
        if "API key not valid" in error_message:
            return "Gemini API hatasÄ±: GeÃ§ersiz API anahtarÄ±. LÃ¼tfen Colab Secrets'Ä± kontrol edin."
        elif "model" in error_message and ("not found" in error_message or "does not exist" in error_message or "permission denied" in error_message):
            return f"Gemini API hatasÄ±: '{model_id}' modeli bulunamadÄ± veya bu API anahtarÄ± ile eriÅŸilemiyor."
        elif "User location is not supported" in error_message:
            return "Gemini API hatasÄ±: BulunduÄŸunuz konum (veya sunucunun konumu) Gemini API tarafÄ±ndan desteklenmiyor."
        elif "RESOURCE_EXHAUSTED" in error_message or "quota" in error_message:
            return "Gemini API hatasÄ±: KullanÄ±m kotasÄ± aÅŸÄ±ldÄ± veya kaynaklar tÃ¼kendi."
        elif "Safety settings triggered" in error_message or "blocked" in error_message:
             # GÃ¼venlik filtreleri nedeniyle engellenen iÃ§eriÄŸin detayÄ±nÄ± logla (hassas olabilir, dikkat!)
             try:
                 print(f"Engellenen iÃ§erik detayÄ± (prompt feedback): {response.prompt_feedback}")
             except Exception: pass # response henÃ¼z oluÅŸmamÄ±ÅŸ olabilir
             return "Gemini API hatasÄ±: Ä°stek veya yanÄ±t gÃ¼venlik filtreleri tarafÄ±ndan engellendi."
        # DiÄŸer hatalar
        return f"Gemini API ile iletiÅŸimde beklenmedik bir hata oluÅŸtu: {error_message}"

def call_openrouter_api(prompt, model_id, persona="", history=None):
    """
    OpenRouter API'sini Ã§aÄŸÄ±rÄ±r.
    Sohbet geÃ§miÅŸini (context) de iÅŸler.
    """
    if not OPENROUTER_API_KEY:
        print("Hata: OpenRouter API Ã§aÄŸrÄ±sÄ± denendi ancak OPENROUTER_API_KEY ayarlÄ± deÄŸil.")
        return "Hata: OpenRouter API anahtarÄ± sunucu tarafÄ±nda ayarlanmamÄ±ÅŸ."

    api_url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        # OpenRouter belgelerine gÃ¶re bu baÅŸlÄ±klar Ã¶nerilir:
        # "HTTP-Referer": "YOUR_SITE_URL", # Frontend'inizin URL'si
        # "X-Title": "YOUR_APP_NAME", # UygulamanÄ±zÄ±n adÄ±
    }

    # API'ye gÃ¶nderilecek mesaj listesini oluÅŸtur
    messages_for_api = []

    # 1. Persona'yÄ± sistem mesajÄ± olarak ekle (OpenRouter bunu destekler)
    if persona:
         messages_for_api.append({"role": "system", "content": f"Sen {persona}."})
    else:
         messages_for_api.append({"role": "system", "content": "Sen yardÄ±mcÄ± bir asistansÄ±n."})


    # 2. Gelen geÃ§miÅŸi ekle (Frontend'den gelen format OpenRouter ile uyumlu: user/assistant)
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role in ['user', 'assistant'] and content: # Sadece geÃ§erli roller ve iÃ§erik
                 messages_for_api.append({"role": role, "content": content})
        print(f"OpenRouter iÃ§in gÃ¶nderilecek geÃ§miÅŸ (ilk 5): {messages_for_api[1:6]}") # Sistem mesajÄ±nÄ± atla
    else:
        print("OpenRouter iÃ§in geÃ§erli bir geÃ§miÅŸ gÃ¶nderilmedi.")


    # 3. Son kullanÄ±cÄ± mesajÄ±nÄ± ekle
    messages_for_api.append({"role": "user", "content": prompt})


    # Ä°stek gÃ¶vdesi
    data = {
        "model": model_id, # Frontend'den gelen model ID'si
        "messages": messages_for_api, # OluÅŸturulan mesaj listesi
        "max_tokens": 2048, # Maksimum yanÄ±t uzunluÄŸu (modele gÃ¶re deÄŸiÅŸebilir)
        "temperature": 0.7 # YaratÄ±cÄ±lÄ±k
        # Gerekirse 'top_p', 'frequency_penalty', 'presence_penalty' gibi diÄŸer parametreler eklenebilir.
    }
    print(f"OpenRouter API isteÄŸi (ilk 5 mesaj): {json.dumps(data['messages'][:5], indent=2)}")


    try:
        # API isteÄŸini gÃ¶nder (timeout sÃ¼resi eklemek iyi bir pratik)
        response = requests.post(api_url, headers=headers, json=data, timeout=60) # Timeout sÃ¼resini 60 saniye yaptÄ±k
        # HTTP hata kodlarÄ± (4xx, 5xx) iÃ§in otomatik hata fÄ±rlat
        response.raise_for_status()
        result = response.json()

        # YanÄ±tÄ±n iÃ§inden mesaj iÃ§eriÄŸini al
        # .get() kullanÄ±mÄ±, anahtar yoksa hata vermek yerine None dÃ¶ndÃ¼rÃ¼r, bu da daha saÄŸlamdÄ±r.
        ai_content = result.get("choices", [{}])[0].get("message", {}).get("content")

        if ai_content:
            return ai_content.strip()
        else:
            print(f"OpenRouter yanÄ±t formatÄ± beklenenden farklÄ± (Model: {model_id}): {result}")
            return "OpenRouter'dan geÃ§erli bir yanÄ±t alÄ±namadÄ±."

    # Ä°stek sÄ±rasÄ±ndaki aÄŸ veya HTTP hatalarÄ±
    except requests.exceptions.RequestException as e:
        print(f"OpenRouter API HatasÄ± (Model: {model_id}): {e}")
        error_detail = str(e)
        status_code = None
        # EÄŸer response nesnesi oluÅŸmuÅŸsa (Ã¶rn: 4xx/5xx hatasÄ±), detaylarÄ± almayÄ± dene
        if e.response is not None:
            status_code = e.response.status_code
            try:
                # Hata detayÄ±nÄ± JSON yanÄ±ttan almayÄ± dene
                error_detail = e.response.json().get('error', {}).get('message', str(e))
            except ValueError: # YanÄ±t JSON deÄŸilse
                error_detail = e.response.text

        # YaygÄ±n HTTP durum kodlarÄ±na gÃ¶re Ã¶zel mesajlar
        if status_code == 401: return "OpenRouter API hatasÄ±: GeÃ§ersiz API anahtarÄ±. Colab Secrets'Ä± kontrol edin."
        if status_code == 402: return "OpenRouter API hatasÄ±: Kredi yetersiz. OpenRouter hesabÄ±nÄ±zÄ± kontrol edin."
        if status_code == 429: return "OpenRouter API hatasÄ±: HÄ±z limiti aÅŸÄ±ldÄ±. LÃ¼tfen biraz bekleyip tekrar deneyin."
        # Model bulunamadÄ± hatasÄ± (OpenRouter genellikle 4xx dÃ¶ner)
        if status_code is not None and status_code >= 400 and status_code < 500 and ("model not found" in error_detail.lower() or "invalid model" in error_detail.lower() or "does not exist" in error_detail.lower()):
             return f"OpenRouter API hatasÄ±: '{model_id}' modeli bulunamadÄ± veya desteklenmiyor."
        if status_code == 400 and "context length" in error_detail.lower(): return "OpenRouter API hatasÄ±: Ä°stek, modelin izin verdiÄŸi maksimum girdi uzunluÄŸunu (context limit) aÅŸÄ±yor."
        # DiÄŸer aÄŸ/HTTP hatalarÄ±
        return f"OpenRouter API ile iletiÅŸimde hata: {error_detail} (HTTP Kodu: {status_code if status_code else 'Bilinmiyor'})"

    # DiÄŸer beklenmedik programlama hatalarÄ±
    except Exception as e:
        print(f"Beklenmedik Hata (OpenRouter - Model: {model_id}): {e}")
        return "OpenRouter yanÄ±tÄ± iÅŸlenirken sunucu tarafÄ±nda beklenmedik bir hata oluÅŸtu."


# --- 7. API Endpoint (/api/chat) ---
@app.route('/api/chat', methods=['POST'])
def chat_handler():
    """Frontend'den gelen POST isteklerini iÅŸler ve uygun AI API'sini Ã§aÄŸÄ±rÄ±r."""
    # Ä°stek gÃ¶vdesini JSON olarak al
    data = request.json
    if not data:
        print("Hata: BoÅŸ veya JSON olmayan istek alÄ±ndÄ±.")
        return jsonify({"error": "GeÃ§ersiz istek formatÄ±. JSON bekleniyor."}), 400 # Bad Request

    # Gerekli ve opsiyonel alanlarÄ± al
    user_message = data.get('message')
    model_id_from_frontend = data.get('modelId') # Frontend'den gelen model ID'si
    history = data.get('history', []) # *** YENÄ°: Sohbet geÃ§miÅŸini al (varsayÄ±lan boÅŸ liste) ***
    character_name = data.get('characterName', 'Bilinmeyen Karakter')
    persona_key = data.get('personaKey', 'default')
    custom_persona_text = data.get('customPersonaText', '')

    # Gerekli alanlarÄ±n varlÄ±ÄŸÄ±nÄ± kontrol et
    if not user_message or not model_id_from_frontend:
        print(f"Hata: Eksik bilgi. Gelen veri: {data}")
        return jsonify({"error": "Eksik bilgi: Ä°stekte 'message' ve 'modelId' alanlarÄ± bulunmalÄ±dÄ±r."}), 400 # Bad Request

    print(f"Gelen istek: Model={model_id_from_frontend}, PersonaKey={persona_key}, Karakter={character_name}, GeÃ§miÅŸ Mesaj SayÄ±sÄ±={len(history)}")

    # Persona aÃ§Ä±klamasÄ±nÄ± belirle
    persona_description = ""
    if persona_key == 'custom' and custom_persona_text:
        persona_description = custom_persona_text
        print("Ã–zel persona kullanÄ±lÄ±yor.")
    elif persona_key == 'witty':
        persona_description = f"{character_name} adÄ±nda esprili, nÃ¼ktedan ve biraz alaycÄ± bir arkadaÅŸsÄ±n. KÄ±sa ve vurucu cevaplar vermeyi seversin."
        print("Esprili persona kullanÄ±lÄ±yor.")
    elif persona_key == 'wise':
        persona_description = f"{character_name} adÄ±nda bilge, sakin ve deneyimli bir Ã¶ÄŸretmensin. AÃ§Ä±klayÄ±cÄ±, sabÄ±rlÄ± ve derinlemesine cevaplar verirsin."
        print("Bilge persona kullanÄ±lÄ±yor.")
    else: # 'default' veya tanÄ±msÄ±z personaKey
        persona_description = f"{character_name} adÄ±nda genel amaÃ§lÄ±, yardÄ±msever ve nazik bir yapay zeka asistanÄ±sÄ±n."
        print("VarsayÄ±lan yardÄ±mcÄ± persona kullanÄ±lÄ±yor.")

    ai_response = "Hata: Model iÅŸlenemedi veya desteklenmiyor."

    # --- Model ID'sine GÃ¶re YÃ¶nlendirme MantÄ±ÄŸÄ± ---
    # Kural:
    # 1. EÄŸer model ID'si bilinen Gemini modellerinden biriyse ve Gemini anahtarÄ± varsa -> Gemini API
    # 2. EÄŸer model ID'si '/' iÃ§eriyorsa (OpenRouter formatÄ±) ve OpenRouter anahtarÄ± varsa -> OpenRouter API
    # 3. DiÄŸer durumlar -> Hata

    is_known_gemini = model_id_from_frontend in known_models_info and known_models_info[model_id_from_frontend]["provider"] == "google"
    is_likely_openrouter = "/" in model_id_from_frontend

    if is_known_gemini:
        if GEMINI_API_KEY:
            print(f"Google Gemini API Ã§aÄŸrÄ±lÄ±yor: Model={model_id_from_frontend}")
            # *** YENÄ°: history parametresini gÃ¶nder ***
            ai_response = call_gemini_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            print("Hata: Gemini modeli istendi ancak GEMINI_API_KEY ayarlanmamÄ±ÅŸ.")
            ai_response = "Hata: Sunucu tarafÄ±nda Gemini API anahtarÄ± yapÄ±landÄ±rÄ±lmamÄ±ÅŸ."
            # return jsonify({"error": ai_response}), 503 # Ä°steÄŸe baÄŸlÄ±: Servis kullanÄ±lamÄ±yor hatasÄ±

    elif is_likely_openrouter:
        if OPENROUTER_API_KEY:
            print(f"OpenRouter API Ã§aÄŸrÄ±lÄ±yor: Model={model_id_from_frontend}")
             # *** YENÄ°: history parametresini gÃ¶nder ***
            ai_response = call_openrouter_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            print("Hata: OpenRouter modeli istendi ancak OPENROUTER_API_KEY ayarlanmamÄ±ÅŸ.")
            ai_response = "Hata: Sunucu tarafÄ±nda OpenRouter API anahtarÄ± yapÄ±landÄ±rÄ±lmamÄ±ÅŸ."
            # return jsonify({"error": ai_response}), 503

    else:
        # Ne bilinen Gemini ne de OpenRouter formatÄ±na uymuyorsa
        print(f"Hata: Desteklenmeyen veya tanÄ±nmayan model ID formatÄ±: '{model_id_from_frontend}'")
        ai_response = f"Hata: Desteklenmeyen veya tanÄ±nmayan model ID formatÄ±: '{model_id_from_frontend}'. Model ID'si 'saÄŸlayÄ±cÄ±/model' formatÄ±nda (OpenRouter) veya bilinen bir Gemini ID'si olmalÄ±dÄ±r."
        # return jsonify({"error": ai_response}), 400 # Bad Request

    # BaÅŸarÄ±lÄ± veya API'den dÃ¶nen hata mesajÄ±nÄ± iÃ§eren yanÄ±tÄ± JSON olarak dÃ¶ndÃ¼r
    print(f"YanÄ±t gÃ¶nderiliyor: {ai_response[:100]}...") # YanÄ±tÄ±n baÅŸÄ±nÄ± logla
    # Not: Backend artÄ±k geÃ§miÅŸi yÃ¶netmediÄŸi iÃ§in yanÄ±t sadece 'reply' iÃ§eriyor.
    # Frontend'deki appendMessage(..., addToHistory=true) geÃ§miÅŸi gÃ¼ncelliyor.
    return jsonify({"reply": ai_response})

# --- 8. UygulamayÄ± ve Ngrok TÃ¼nelini BaÅŸlat ---
PORT = 5000 # Flask sunucusunun Ã§alÄ±ÅŸacaÄŸÄ± port

def run_flask():
    """Flask uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±r."""
    # use_reloader=False: Colab'da genellikle False olmasÄ± Ã¶nerilir.
    # debug=False: Ãœretim ortamÄ± iÃ§in False olmalÄ±. Hata ayÄ±klama iÃ§in True yapabilirsiniz ama public URL'de dikkatli olun.
    print(f"Flask uygulamasÄ± http://127.0.0.1:{PORT} adresinde baÅŸlatÄ±lÄ±yor...")
    # host='0.0.0.0' tÃ¼m aÄŸ arayÃ¼zlerinden eriÅŸime izin verir (Colab iÃ§in gerekli olabilir)
    app.run(port=PORT, host='0.0.0.0', use_reloader=False, debug=False)

if __name__ == '__main__':
    # Ã–nceki ngrok iÅŸlemlerini sonlandÄ±rmayÄ± dene (Colab'da tekrar Ã§alÄ±ÅŸtÄ±rmada sorun olmamasÄ± iÃ§in)
    try:
        ngrok.kill()
        print("Mevcut ngrok iÅŸlemleri (varsa) sonlandÄ±rÄ±ldÄ±.")
    except Exception as e:
        print(f"Mevcut ngrok iÅŸlemleri sonlandÄ±rÄ±lamadÄ± (genellikle sorun deÄŸil): {e}")

    # Ngrok tÃ¼nelini baÅŸlat
    try:
        if not NGROK_AUTHTOKEN:
             print("\nUYARI: Ngrok Authtoken ayarlanmadÄ±ÄŸÄ± iÃ§in Ngrok tÃ¼neli baÅŸlatÄ±lamÄ±yor.")
             print("LÃ¼tfen Colab Secrets'a NGROK_AUTHTOKEN ekleyin ve hÃ¼creyi tekrar Ã§alÄ±ÅŸtÄ±rÄ±n.")
             # Token yoksa Flask'Ä± baÅŸlatma, Ã§Ã¼nkÃ¼ eriÅŸilemez olacak.
        else:
            # Ngrok tÃ¼nelini belirtilen porta baÄŸla
            public_url = ngrok.connect(PORT)
            print("--------------------------------------------------------------------------")
            print(f"âœ… Ngrok TÃ¼neli BaÅŸarÄ±yla OluÅŸturuldu!")
            print(f"   Public URL: {public_url}")
            print(f"   Bu URL, yerel Flask sunucunuza ({PORT}) yÃ¶nlendirir.")
            print("--------------------------------------------------------------------------")
            print("\nFlask uygulamasÄ± (Context Destekli Gemini & OpenRouter ile) baÅŸlatÄ±lÄ±yor...")
            # print(f" * Bilinen Modeller (Bilgi AmaÃ§lÄ±): {list(known_models_info.keys())}") # ArtÄ±k Ã§ok Ã¶nemli deÄŸil
            print("\nğŸš¨ Ã–NEMLÄ°: Frontend uygulamanÄ±zdaki API URL'sini")
            print(f"   ÅŸu ÅŸekilde gÃ¼ncelleyin: {public_url}/api/chat")
            print("--------------------------------------------------------------------------\n")

            # Flask uygulamasÄ±nÄ± ayrÄ± bir thread'de baÅŸlatmak Colab'da daha stabil olabilir
            # flask_thread = threading.Thread(target=run_flask)
            # flask_thread.start()
            # Direkt Ã§alÄ±ÅŸtÄ±rma da genellikle iÅŸe yarar:
            run_flask()

    except Exception as e:
        print("\nâŒ HATA: Ngrok tÃ¼neli baÅŸlatÄ±lÄ±rken veya Flask Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken ciddi bir hata oluÅŸtu.")
        print(f"Hata DetayÄ±: {e}")
        error_str = str(e).lower()
        if "authentication failed" in error_str or "authtoken" in error_str or "401" in error_str:
            print("-> Muhtemel Neden: Ngrok kimlik doÄŸrulamasÄ± baÅŸarÄ±sÄ±z oldu.")
            print("   LÃ¼tfen Colab Secrets'taki 'NGROK_AUTHTOKEN' deÄŸerinin doÄŸru ve geÃ§erli olduÄŸundan emin olun.")
        elif "could not connect" in error_str or "connection refused" in error_str:
            print("-> Muhtemel Neden: Ngrok servisine veya yerel porta baÄŸlanÄ±lamadÄ±.")
            print("   Ä°nternet baÄŸlantÄ±nÄ±zÄ± ve portun baÅŸka bir uygulama tarafÄ±ndan kullanÄ±lmadÄ±ÄŸÄ±nÄ± kontrol edin.")
        elif "port already in use" in error_str or "address already in use" in error_str:
             print(f"-> Muhtemel Neden: {PORT} portu zaten baÅŸka bir iÅŸlem tarafÄ±ndan kullanÄ±lÄ±yor.")
             print("   Colab Runtime'Ä± yeniden baÅŸlatmayÄ± veya farklÄ± bir PORT deÄŸeri denemeyi dÃ¼ÅŸÃ¼nÃ¼n.")
        else:
            print("-> LÃ¼tfen Ngrok Authtoken'Ä±nÄ±zÄ±n Colab Secrets'ta doÄŸru ayarlandÄ±ÄŸÄ±ndan ve internet baÄŸlantÄ±nÄ±zÄ±n olduÄŸundan emin olun.")

