# -*- coding: utf-8 -*-

# --- 1. Gerekli Kütüphaneleri Yükle ---
# Flask: Web sunucusu framework'ü
# Flask-Cors: Tarayıcıların farklı kaynaklardan gelen isteklerine izin vermek için (Cross-Origin Resource Sharing)
# requests: Harici API'lere HTTP istekleri göndermek için
# pyngrok: Yerel Flask sunucusunu internete açmak için (Colab'da kullanışlı)
# google-generativeai: Google Gemini API'si için resmi Python kütüphanesi
!pip install Flask Flask-Cors requests pyngrok google-generativeai -q
print("Gerekli kütüphaneler yüklendi.")

# --- 2. Kütüphaneleri ve Modülleri İçe Aktar ---
import os
import requests
from flask import Flask, request, jsonify
from flask_cors import CORS
from pyngrok import ngrok, conf
import google.generativeai as genai
import threading # Flask'ı ayrı bir thread'de çalıştırmak için (Colab'da bazen gerekli)
import json # JSON işleme için

# --- 3. API Anahtarlarını ve Ngrok Token'ını Al ---
# Google Colab'ın Secrets (Gizli Anahtarlar) özelliğini kullanarak API anahtarlarını güvenli bir şekilde saklayın.
# Sol menüdeki anahtar (🔑) ikonuna tıklayarak şu isimlerle ekleyin:
# GEMINI_API_KEY, OPENROUTER_API_KEY, NGROK_AUTHTOKEN
try:
    from google.colab import userdata
    GEMINI_API_KEY = userdata.get('GEMINI_API_KEY')
    OPENROUTER_API_KEY = userdata.get('OPENROUTER_API_KEY') # OpenRouter anahtarını al
    NGROK_AUTHTOKEN = userdata.get('NGROK_AUTHTOKEN')
    print("API anahtarları ve Ngrok Authtoken Colab Secrets'tan başarıyla alındı.")

    # Gemini API'sini yapılandır
    if GEMINI_API_KEY:
        genai.configure(api_key=GEMINI_API_KEY)
        print("Google Gemini API başarıyla yapılandırıldı.")
    else:
        print("Uyarı: Colab Secrets'ta 'GEMINI_API_KEY' bulunamadı. Gemini modelleri çalışmayacak.")

    # Ngrok'u yapılandır (Ngrok tünelinin kimlik doğrulaması için)
    if NGROK_AUTHTOKEN:
        conf.get_default().auth_token = NGROK_AUTHTOKEN
        print("Ngrok Authtoken başarıyla ayarlandı.")
    else:
        print("Uyarı: Colab Secrets'ta 'NGROK_AUTHTOKEN' bulunamadı. Ngrok tüneli kısıtlı olabilir veya çalışmayabilir.")

    # OpenRouter anahtarının varlığını kontrol et
    if not OPENROUTER_API_KEY:
        print("Uyarı: Colab Secrets'ta 'OPENROUTER_API_KEY' bulunamadı. OpenRouter modelleri çalışmayacak.")

# Colab ortamında değilse veya userdata modülü yoksa
except ImportError:
    print("Google Colab ortamında değilsiniz veya 'userdata' modülü bulunamadı. API anahtarları manuel olarak ayarlanmalı veya ortam değişkenlerinden okunmalı.")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None
# Secrets'ta anahtar eksikse
except KeyError as e:
      print(f"Colab Secrets'ta eksik anahtar: {e}. Lütfen sol menüden (🔑) gerekli anahtarları ekleyin.")
      # Eksik anahtarları None olarak ayarla ki program devam edebilsin (ama ilgili API çalışmaz)
      if 'GEMINI_API_KEY' not in locals(): GEMINI_API_KEY = None
      if 'OPENROUTER_API_KEY' not in locals(): OPENROUTER_API_KEY = None
      if 'NGROK_AUTHTOKEN' not in locals(): NGROK_AUTHTOKEN = None
# Diğer beklenmedik hatalar
except Exception as e:
    print(f"API anahtarı veya Ngrok token yapılandırılırken genel bir hata oluştu: {e}")
    GEMINI_API_KEY = None
    OPENROUTER_API_KEY = None
    NGROK_AUTHTOKEN = None


# --- 4. Flask Uygulamasını Başlat ---
app = Flask(__name__)
# CORS(app) tüm kaynaklardan gelen isteklere izin verir.
# Daha güvenli bir yapılandırma için origin'leri belirtebilirsiniz: CORS(app, resources={r"/api/*": {"origins": "YOUR_FRONTEND_URL"}})
CORS(app)

# --- 5. Bilinen Modeller (Bilgi amaçlı, katı kontrol için değil) ---
# Bu sözlük, hangi model ID'sinin hangi sağlayıcıya ait olduğunu hızlıca anlamak için kullanılabilir.
# Ancak API yönlendirme mantığı doğrudan model ID formatına (örn: '/' içeriyor mu?) bakıyor.
known_models_info = {
    # Gemini Modelleri (Google)
    "gemini-pro": { "name": "Gemini 1.0 Pro (Google)", "provider": "google" },
    "gemini-1.5-flash-latest": { "name": "Gemini 1.5 Flash (Google)", "provider": "google" },
    # OpenRouter üzerinden erişilebilen örnek modeller
    # OpenRouter model ID'leri genellikle "sağlayıcı/model-adı" formatındadır.
    "openai/gpt-4o-mini": { "name": "GPT-4o Mini (OpenRouter)", "provider": "openrouter" },
    "anthropic/claude-3-haiku-20240307": { "name": "Claude 3 Haiku (OpenRouter)", "provider": "openrouter" },
    "mistralai/mistral-7b-instruct": { "name": "Mistral 7B Instruct (OpenRouter)", "provider": "openrouter" },
    "google/gemini-pro": { "name": "Gemini Pro (OpenRouter)", "provider": "openrouter" }, # Gemini'ye OpenRouter üzerinden de erişilebilir
    "gryphe/mythomax-l2-13b": { "name": "MythoMax L2 13B (OpenRouter)", "provider": "openrouter", "isPremium": True } # Örnek: Premium model bilgisi
}


# --- 6. AI API Çağrı Fonksiyonları ---

def call_gemini_api(prompt, model_id="gemini-pro", persona="", history=None):
    """
    Google Gemini API'sini resmi kütüphane kullanarak çağırır.
    Sohbet geçmişini (context) de işler.
    """
    if not GEMINI_API_KEY:
        print("Hata: Gemini API çağrısı denendi ancak GEMINI_API_KEY ayarlı değil.")
        return "Hata: Gemini API anahtarı sunucu tarafında ayarlanmamış."

    # Gelen geçmişi Gemini formatına dönüştür: [{'role': 'user'/'model', 'parts': [text]}]
    # Frontend'den gelen 'assistant' rolünü 'model' olarak değiştir.
    converted_history = []
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role and content:
                # Gemini API 'assistant' yerine 'model' rolünü bekler
                gemini_role = 'model' if role == 'assistant' else role
                if gemini_role in ['user', 'model']: # Sadece geçerli rolleri ekle
                    converted_history.append({'role': gemini_role, 'parts': [content]})
        print(f"Gemini için dönüştürülmüş geçmiş (ilk 5): {converted_history[:5]}")
    else:
         print("Gemini için geçerli bir geçmiş gönderilmedi.")


    try:
        # Varsayılan üretim yapılandırması
        default_max_output = 8192
        generation_config = {
            "temperature": 0.7,
            "top_p": 1.0,
            "top_k": 1,
            "max_output_tokens": default_max_output
        }
        # Güvenlik ayarları
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
        ]

        actual_model_name_for_api = model_id
        model = genai.GenerativeModel(
            model_name=actual_model_name_for_api,
            generation_config=generation_config,
            safety_settings=safety_settings
        )

        # Persona bilgisini prompt'a ekle (isteğe bağlı, sistem mesajı gibi düşünülebilir)
        # Veya persona'yı geçmişin başına bir sistem mesajı olarak ekleyebilirsiniz.
        # Şimdilik prompt'a ekliyoruz.
        full_prompt = f"Senin görevin: {persona if persona else 'yardımcı bir asistansın'}. Kullanıcının mesajı: {prompt}"

        # Sohbeti geçmişle başlat
        # ÖNEMLİ: Gemini kütüphanesi history'yi doğrudan `start_chat` içinde alır.
        # Eğer `send_message` kullanacaksak, prompt'u geçmişin sonuna eklememiz gerekebilir.
        # `start_chat` kullanmak daha temiz görünüyor.
        chat = model.start_chat(history=converted_history) # Dönüştürülmüş geçmişi kullan
        response = chat.send_message(prompt) # Sadece yeni mesajı gönder

        # Yanıtı temizleyip döndür
        return response.text.strip()

    # Hata yakalama
    except Exception as e:
        print(f"Gemini Kütüphane Hatası (Model: {model_id}): {e}")
        error_message = str(e)
        # Yaygın hatalar için daha açıklayıcı mesajlar
        if "API key not valid" in error_message:
            return "Gemini API hatası: Geçersiz API anahtarı. Lütfen Colab Secrets'ı kontrol edin."
        elif "model" in error_message and ("not found" in error_message or "does not exist" in error_message or "permission denied" in error_message):
            return f"Gemini API hatası: '{model_id}' modeli bulunamadı veya bu API anahtarı ile erişilemiyor."
        elif "User location is not supported" in error_message:
            return "Gemini API hatası: Bulunduğunuz konum (veya sunucunun konumu) Gemini API tarafından desteklenmiyor."
        elif "RESOURCE_EXHAUSTED" in error_message or "quota" in error_message:
            return "Gemini API hatası: Kullanım kotası aşıldı veya kaynaklar tükendi."
        elif "Safety settings triggered" in error_message or "blocked" in error_message:
             # Güvenlik filtreleri nedeniyle engellenen içeriğin detayını logla (hassas olabilir, dikkat!)
             try:
                 print(f"Engellenen içerik detayı (prompt feedback): {response.prompt_feedback}")
             except Exception: pass # response henüz oluşmamış olabilir
             return "Gemini API hatası: İstek veya yanıt güvenlik filtreleri tarafından engellendi."
        # Diğer hatalar
        return f"Gemini API ile iletişimde beklenmedik bir hata oluştu: {error_message}"

def call_openrouter_api(prompt, model_id, persona="", history=None):
    """
    OpenRouter API'sini çağırır.
    Sohbet geçmişini (context) de işler.
    """
    if not OPENROUTER_API_KEY:
        print("Hata: OpenRouter API çağrısı denendi ancak OPENROUTER_API_KEY ayarlı değil.")
        return "Hata: OpenRouter API anahtarı sunucu tarafında ayarlanmamış."

    api_url = "https://openrouter.ai/api/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        # OpenRouter belgelerine göre bu başlıklar önerilir:
        # "HTTP-Referer": "YOUR_SITE_URL", # Frontend'inizin URL'si
        # "X-Title": "YOUR_APP_NAME", # Uygulamanızın adı
    }

    # API'ye gönderilecek mesaj listesini oluştur
    messages_for_api = []

    # 1. Persona'yı sistem mesajı olarak ekle (OpenRouter bunu destekler)
    if persona:
         messages_for_api.append({"role": "system", "content": f"Sen {persona}."})
    else:
         messages_for_api.append({"role": "system", "content": "Sen yardımcı bir asistansın."})


    # 2. Gelen geçmişi ekle (Frontend'den gelen format OpenRouter ile uyumlu: user/assistant)
    if history and isinstance(history, list):
        for msg in history:
            role = msg.get('role')
            content = msg.get('content')
            if role in ['user', 'assistant'] and content: # Sadece geçerli roller ve içerik
                 messages_for_api.append({"role": role, "content": content})
        print(f"OpenRouter için gönderilecek geçmiş (ilk 5): {messages_for_api[1:6]}") # Sistem mesajını atla
    else:
        print("OpenRouter için geçerli bir geçmiş gönderilmedi.")


    # 3. Son kullanıcı mesajını ekle
    messages_for_api.append({"role": "user", "content": prompt})


    # İstek gövdesi
    data = {
        "model": model_id, # Frontend'den gelen model ID'si
        "messages": messages_for_api, # Oluşturulan mesaj listesi
        "max_tokens": 2048, # Maksimum yanıt uzunluğu (modele göre değişebilir)
        "temperature": 0.7 # Yaratıcılık
        # Gerekirse 'top_p', 'frequency_penalty', 'presence_penalty' gibi diğer parametreler eklenebilir.
    }
    print(f"OpenRouter API isteği (ilk 5 mesaj): {json.dumps(data['messages'][:5], indent=2)}")


    try:
        # API isteğini gönder (timeout süresi eklemek iyi bir pratik)
        response = requests.post(api_url, headers=headers, json=data, timeout=60) # Timeout süresini 60 saniye yaptık
        # HTTP hata kodları (4xx, 5xx) için otomatik hata fırlat
        response.raise_for_status()
        result = response.json()

        # Yanıtın içinden mesaj içeriğini al
        # .get() kullanımı, anahtar yoksa hata vermek yerine None döndürür, bu da daha sağlamdır.
        ai_content = result.get("choices", [{}])[0].get("message", {}).get("content")

        if ai_content:
            return ai_content.strip()
        else:
            print(f"OpenRouter yanıt formatı beklenenden farklı (Model: {model_id}): {result}")
            return "OpenRouter'dan geçerli bir yanıt alınamadı."

    # İstek sırasındaki ağ veya HTTP hataları
    except requests.exceptions.RequestException as e:
        print(f"OpenRouter API Hatası (Model: {model_id}): {e}")
        error_detail = str(e)
        status_code = None
        # Eğer response nesnesi oluşmuşsa (örn: 4xx/5xx hatası), detayları almayı dene
        if e.response is not None:
            status_code = e.response.status_code
            try:
                # Hata detayını JSON yanıttan almayı dene
                error_detail = e.response.json().get('error', {}).get('message', str(e))
            except ValueError: # Yanıt JSON değilse
                error_detail = e.response.text

        # Yaygın HTTP durum kodlarına göre özel mesajlar
        if status_code == 401: return "OpenRouter API hatası: Geçersiz API anahtarı. Colab Secrets'ı kontrol edin."
        if status_code == 402: return "OpenRouter API hatası: Kredi yetersiz. OpenRouter hesabınızı kontrol edin."
        if status_code == 429: return "OpenRouter API hatası: Hız limiti aşıldı. Lütfen biraz bekleyip tekrar deneyin."
        # Model bulunamadı hatası (OpenRouter genellikle 4xx döner)
        if status_code is not None and status_code >= 400 and status_code < 500 and ("model not found" in error_detail.lower() or "invalid model" in error_detail.lower() or "does not exist" in error_detail.lower()):
             return f"OpenRouter API hatası: '{model_id}' modeli bulunamadı veya desteklenmiyor."
        if status_code == 400 and "context length" in error_detail.lower(): return "OpenRouter API hatası: İstek, modelin izin verdiği maksimum girdi uzunluğunu (context limit) aşıyor."
        # Diğer ağ/HTTP hataları
        return f"OpenRouter API ile iletişimde hata: {error_detail} (HTTP Kodu: {status_code if status_code else 'Bilinmiyor'})"

    # Diğer beklenmedik programlama hataları
    except Exception as e:
        print(f"Beklenmedik Hata (OpenRouter - Model: {model_id}): {e}")
        return "OpenRouter yanıtı işlenirken sunucu tarafında beklenmedik bir hata oluştu."


# --- 7. API Endpoint (/api/chat) ---
@app.route('/api/chat', methods=['POST'])
def chat_handler():
    """Frontend'den gelen POST isteklerini işler ve uygun AI API'sini çağırır."""
    # İstek gövdesini JSON olarak al
    data = request.json
    if not data:
        print("Hata: Boş veya JSON olmayan istek alındı.")
        return jsonify({"error": "Geçersiz istek formatı. JSON bekleniyor."}), 400 # Bad Request

    # Gerekli ve opsiyonel alanları al
    user_message = data.get('message')
    model_id_from_frontend = data.get('modelId') # Frontend'den gelen model ID'si
    history = data.get('history', []) # *** YENİ: Sohbet geçmişini al (varsayılan boş liste) ***
    character_name = data.get('characterName', 'Bilinmeyen Karakter')
    persona_key = data.get('personaKey', 'default')
    custom_persona_text = data.get('customPersonaText', '')

    # Gerekli alanların varlığını kontrol et
    if not user_message or not model_id_from_frontend:
        print(f"Hata: Eksik bilgi. Gelen veri: {data}")
        return jsonify({"error": "Eksik bilgi: İstekte 'message' ve 'modelId' alanları bulunmalıdır."}), 400 # Bad Request

    print(f"Gelen istek: Model={model_id_from_frontend}, PersonaKey={persona_key}, Karakter={character_name}, Geçmiş Mesaj Sayısı={len(history)}")

    # Persona açıklamasını belirle
    persona_description = ""
    if persona_key == 'custom' and custom_persona_text:
        persona_description = custom_persona_text
        print("Özel persona kullanılıyor.")
    elif persona_key == 'witty':
        persona_description = f"{character_name} adında esprili, nüktedan ve biraz alaycı bir arkadaşsın. Kısa ve vurucu cevaplar vermeyi seversin."
        print("Esprili persona kullanılıyor.")
    elif persona_key == 'wise':
        persona_description = f"{character_name} adında bilge, sakin ve deneyimli bir öğretmensin. Açıklayıcı, sabırlı ve derinlemesine cevaplar verirsin."
        print("Bilge persona kullanılıyor.")
    else: # 'default' veya tanımsız personaKey
        persona_description = f"{character_name} adında genel amaçlı, yardımsever ve nazik bir yapay zeka asistanısın."
        print("Varsayılan yardımcı persona kullanılıyor.")

    ai_response = "Hata: Model işlenemedi veya desteklenmiyor."

    # --- Model ID'sine Göre Yönlendirme Mantığı ---
    # Kural:
    # 1. Eğer model ID'si bilinen Gemini modellerinden biriyse ve Gemini anahtarı varsa -> Gemini API
    # 2. Eğer model ID'si '/' içeriyorsa (OpenRouter formatı) ve OpenRouter anahtarı varsa -> OpenRouter API
    # 3. Diğer durumlar -> Hata

    is_known_gemini = model_id_from_frontend in known_models_info and known_models_info[model_id_from_frontend]["provider"] == "google"
    is_likely_openrouter = "/" in model_id_from_frontend

    if is_known_gemini:
        if GEMINI_API_KEY:
            print(f"Google Gemini API çağrılıyor: Model={model_id_from_frontend}")
            # *** YENİ: history parametresini gönder ***
            ai_response = call_gemini_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            print("Hata: Gemini modeli istendi ancak GEMINI_API_KEY ayarlanmamış.")
            ai_response = "Hata: Sunucu tarafında Gemini API anahtarı yapılandırılmamış."
            # return jsonify({"error": ai_response}), 503 # İsteğe bağlı: Servis kullanılamıyor hatası

    elif is_likely_openrouter:
        if OPENROUTER_API_KEY:
            print(f"OpenRouter API çağrılıyor: Model={model_id_from_frontend}")
             # *** YENİ: history parametresini gönder ***
            ai_response = call_openrouter_api(user_message, model_id_from_frontend, persona_description, history)
        else:
            print("Hata: OpenRouter modeli istendi ancak OPENROUTER_API_KEY ayarlanmamış.")
            ai_response = "Hata: Sunucu tarafında OpenRouter API anahtarı yapılandırılmamış."
            # return jsonify({"error": ai_response}), 503

    else:
        # Ne bilinen Gemini ne de OpenRouter formatına uymuyorsa
        print(f"Hata: Desteklenmeyen veya tanınmayan model ID formatı: '{model_id_from_frontend}'")
        ai_response = f"Hata: Desteklenmeyen veya tanınmayan model ID formatı: '{model_id_from_frontend}'. Model ID'si 'sağlayıcı/model' formatında (OpenRouter) veya bilinen bir Gemini ID'si olmalıdır."
        # return jsonify({"error": ai_response}), 400 # Bad Request

    # Başarılı veya API'den dönen hata mesajını içeren yanıtı JSON olarak döndür
    print(f"Yanıt gönderiliyor: {ai_response[:100]}...") # Yanıtın başını logla
    # Not: Backend artık geçmişi yönetmediği için yanıt sadece 'reply' içeriyor.
    # Frontend'deki appendMessage(..., addToHistory=true) geçmişi güncelliyor.
    return jsonify({"reply": ai_response})

# --- 8. Uygulamayı ve Ngrok Tünelini Başlat ---
PORT = 5000 # Flask sunucusunun çalışacağı port

def run_flask():
    """Flask uygulamasını çalıştırır."""
    # use_reloader=False: Colab'da genellikle False olması önerilir.
    # debug=False: Üretim ortamı için False olmalı. Hata ayıklama için True yapabilirsiniz ama public URL'de dikkatli olun.
    print(f"Flask uygulaması http://127.0.0.1:{PORT} adresinde başlatılıyor...")
    # host='0.0.0.0' tüm ağ arayüzlerinden erişime izin verir (Colab için gerekli olabilir)
    app.run(port=PORT, host='0.0.0.0', use_reloader=False, debug=False)

if __name__ == '__main__':
    # Önceki ngrok işlemlerini sonlandırmayı dene (Colab'da tekrar çalıştırmada sorun olmaması için)
    try:
        ngrok.kill()
        print("Mevcut ngrok işlemleri (varsa) sonlandırıldı.")
    except Exception as e:
        print(f"Mevcut ngrok işlemleri sonlandırılamadı (genellikle sorun değil): {e}")

    # Ngrok tünelini başlat
    try:
        if not NGROK_AUTHTOKEN:
             print("\nUYARI: Ngrok Authtoken ayarlanmadığı için Ngrok tüneli başlatılamıyor.")
             print("Lütfen Colab Secrets'a NGROK_AUTHTOKEN ekleyin ve hücreyi tekrar çalıştırın.")
             # Token yoksa Flask'ı başlatma, çünkü erişilemez olacak.
        else:
            # Ngrok tünelini belirtilen porta bağla
            public_url = ngrok.connect(PORT)
            print("--------------------------------------------------------------------------")
            print(f"✅ Ngrok Tüneli Başarıyla Oluşturuldu!")
            print(f"   Public URL: {public_url}")
            print(f"   Bu URL, yerel Flask sunucunuza ({PORT}) yönlendirir.")
            print("--------------------------------------------------------------------------")
            print("\nFlask uygulaması (Context Destekli Gemini & OpenRouter ile) başlatılıyor...")
            # print(f" * Bilinen Modeller (Bilgi Amaçlı): {list(known_models_info.keys())}") # Artık çok önemli değil
            print("\n🚨 ÖNEMLİ: Frontend uygulamanızdaki API URL'sini")
            print(f"   şu şekilde güncelleyin: {public_url}/api/chat")
            print("--------------------------------------------------------------------------\n")

            # Flask uygulamasını ayrı bir thread'de başlatmak Colab'da daha stabil olabilir
            # flask_thread = threading.Thread(target=run_flask)
            # flask_thread.start()
            # Direkt çalıştırma da genellikle işe yarar:
            run_flask()

    except Exception as e:
        print("\n❌ HATA: Ngrok tüneli başlatılırken veya Flask çalıştırılırken ciddi bir hata oluştu.")
        print(f"Hata Detayı: {e}")
        error_str = str(e).lower()
        if "authentication failed" in error_str or "authtoken" in error_str or "401" in error_str:
            print("-> Muhtemel Neden: Ngrok kimlik doğrulaması başarısız oldu.")
            print("   Lütfen Colab Secrets'taki 'NGROK_AUTHTOKEN' değerinin doğru ve geçerli olduğundan emin olun.")
        elif "could not connect" in error_str or "connection refused" in error_str:
            print("-> Muhtemel Neden: Ngrok servisine veya yerel porta bağlanılamadı.")
            print("   İnternet bağlantınızı ve portun başka bir uygulama tarafından kullanılmadığını kontrol edin.")
        elif "port already in use" in error_str or "address already in use" in error_str:
             print(f"-> Muhtemel Neden: {PORT} portu zaten başka bir işlem tarafından kullanılıyor.")
             print("   Colab Runtime'ı yeniden başlatmayı veya farklı bir PORT değeri denemeyi düşünün.")
        else:
            print("-> Lütfen Ngrok Authtoken'ınızın Colab Secrets'ta doğru ayarlandığından ve internet bağlantınızın olduğundan emin olun.")

